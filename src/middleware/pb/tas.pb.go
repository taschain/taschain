// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tas.proto

/*
	Package tas_middleware_pb is a generated protocol buffer package.

	It is generated from these files:
		tas.proto

	It has these top-level messages:
		Message
		Transaction
		TransactionRequestMessage
		TrieNodes
		TransactionSlice
		ChainPieceInfo
		BlockHeader
		BlockBody
		Block
		BlockSlice
		Member
		GroupHeader
		Group
		GroupInfo
		GroupSlice
		GroupIdSlice
		GroupRequestInfo
		Hashes
		TotalQnInfo
		StateInfoReq
		StateInfo
		TrieNode
		SignData
		ConsensusGroupInitSummary
		PubKeyInfo
		ConsensusGroupInitInfo
		ConsensusGroupRawMessage
		SharePiece
		ConsensusSharePieceMessage
		ConsensusSignPubKeyMessage
		ConsensusSignPubkeyReqMessage
		StaticGroupSummary
		ConsensusGroupInitedMessage
		ConsensusCurrentMessage
		ConsensusCastMessage
		ConsensusVerifyMessage
		ConsensusBlockMessage
		ConsensusCreateGroupRawMessage
		ConsensusCreateGroupSignMessage
		Bonus
		CastRewardTransSignReqMessage
		CastRewardTransSignMessage
		TopBlockInfo
		BlockResponseMsg
		ChainPieceBlockMsg
		CreateGroupPingMessage
		CreateGroupPongMessage
		ReqSharePieceMessage
		ResponseSharePieceMessage
*/
package tas_middleware_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Message struct {
	Code             *uint32 `protobuf:"varint,1,req,name=Code" json:"Code,omitempty"`
	Signature        []byte  `protobuf:"bytes,2,opt,name=Signature" json:"Signature,omitempty"`
	Body             []byte  `protobuf:"bytes,3,opt,name=Body" json:"Body,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{0} }

func (m *Message) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *Message) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Message) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type Transaction struct {
	Data             []byte  `protobuf:"bytes,1,opt,name=Data" json:"Data,omitempty"`
	Value            *uint64 `protobuf:"varint,2,opt,name=Value" json:"Value,omitempty"`
	Nonce            *uint64 `protobuf:"varint,3,req,name=Nonce" json:"Nonce,omitempty"`
	Target           []byte  `protobuf:"bytes,4,opt,name=Target" json:"Target,omitempty"`
	GasLimit         *uint64 `protobuf:"varint,5,req,name=GasLimit" json:"GasLimit,omitempty"`
	GasPrice         *uint64 `protobuf:"varint,6,req,name=GasPrice" json:"GasPrice,omitempty"`
	Hash             []byte  `protobuf:"bytes,7,req,name=Hash" json:"Hash,omitempty"`
	ExtraData        []byte  `protobuf:"bytes,8,opt,name=ExtraData" json:"ExtraData,omitempty"`
	ExtraDataType    *int32  `protobuf:"varint,9,opt,name=ExtraDataType" json:"ExtraDataType,omitempty"`
	Type             *int32  `protobuf:"varint,10,req,name=Type" json:"Type,omitempty"`
	Sign             []byte  `protobuf:"bytes,11,opt,name=Sign" json:"Sign,omitempty"`
	TargetAccount    *string `protobuf:"bytes,12,opt,name=TargetAccount" json:"TargetAccount,omitempty"`
	SourceAccount    *string `protobuf:"bytes,13,opt,name=SourceAccount" json:"SourceAccount,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (m *Transaction) String() string            { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{1} }

func (m *Transaction) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Transaction) GetValue() uint64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

func (m *Transaction) GetNonce() uint64 {
	if m != nil && m.Nonce != nil {
		return *m.Nonce
	}
	return 0
}

func (m *Transaction) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Transaction) GetGasLimit() uint64 {
	if m != nil && m.GasLimit != nil {
		return *m.GasLimit
	}
	return 0
}

func (m *Transaction) GetGasPrice() uint64 {
	if m != nil && m.GasPrice != nil {
		return *m.GasPrice
	}
	return 0
}

func (m *Transaction) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *Transaction) GetExtraData() []byte {
	if m != nil {
		return m.ExtraData
	}
	return nil
}

func (m *Transaction) GetExtraDataType() int32 {
	if m != nil && m.ExtraDataType != nil {
		return *m.ExtraDataType
	}
	return 0
}

func (m *Transaction) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *Transaction) GetSign() []byte {
	if m != nil {
		return m.Sign
	}
	return nil
}

func (m *Transaction) GetTargetAccount() string {
	if m != nil && m.TargetAccount != nil {
		return *m.TargetAccount
	}
	return ""
}

func (m *Transaction) GetSourceAccount() string {
	if m != nil && m.SourceAccount != nil {
		return *m.SourceAccount
	}
	return ""
}

type TransactionRequestMessage struct {
	TransactionHashes [][]byte `protobuf:"bytes,1,rep,name=TransactionHashes" json:"TransactionHashes,omitempty"`
	CurrentBlockHash  []byte   `protobuf:"bytes,2,req,name=CurrentBlockHash" json:"CurrentBlockHash,omitempty"`
	XXX_unrecognized  []byte   `json:"-"`
}

func (m *TransactionRequestMessage) Reset()                    { *m = TransactionRequestMessage{} }
func (m *TransactionRequestMessage) String() string            { return proto.CompactTextString(m) }
func (*TransactionRequestMessage) ProtoMessage()               {}
func (*TransactionRequestMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{2} }

func (m *TransactionRequestMessage) GetTransactionHashes() [][]byte {
	if m != nil {
		return m.TransactionHashes
	}
	return nil
}

func (m *TransactionRequestMessage) GetCurrentBlockHash() []byte {
	if m != nil {
		return m.CurrentBlockHash
	}
	return nil
}

type TrieNodes struct {
	TrieNodes        []*TrieNode `protobuf:"bytes,1,rep,name=TrieNodes" json:"TrieNodes,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TrieNodes) Reset()                    { *m = TrieNodes{} }
func (m *TrieNodes) String() string            { return proto.CompactTextString(m) }
func (*TrieNodes) ProtoMessage()               {}
func (*TrieNodes) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{3} }

func (m *TrieNodes) GetTrieNodes() []*TrieNode {
	if m != nil {
		return m.TrieNodes
	}
	return nil
}

type TransactionSlice struct {
	Transactions     []*Transaction `protobuf:"bytes,1,rep,name=transactions" json:"transactions,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *TransactionSlice) Reset()                    { *m = TransactionSlice{} }
func (m *TransactionSlice) String() string            { return proto.CompactTextString(m) }
func (*TransactionSlice) ProtoMessage()               {}
func (*TransactionSlice) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{4} }

func (m *TransactionSlice) GetTransactions() []*Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type ChainPieceInfo struct {
	Pieces           [][]byte `protobuf:"bytes,1,rep,name=Pieces" json:"Pieces,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ChainPieceInfo) Reset()                    { *m = ChainPieceInfo{} }
func (m *ChainPieceInfo) String() string            { return proto.CompactTextString(m) }
func (*ChainPieceInfo) ProtoMessage()               {}
func (*ChainPieceInfo) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{5} }

func (m *ChainPieceInfo) GetPieces() [][]byte {
	if m != nil {
		return m.Pieces
	}
	return nil
}

type BlockHeader struct {
	Hash             []byte  `protobuf:"bytes,1,opt,name=Hash" json:"Hash,omitempty"`
	Height           *uint64 `protobuf:"varint,2,opt,name=Height" json:"Height,omitempty"`
	PreHash          []byte  `protobuf:"bytes,3,opt,name=PreHash" json:"PreHash,omitempty"`
	PreTime          []byte  `protobuf:"bytes,4,opt,name=PreTime" json:"PreTime,omitempty"`
	ProveValue       []byte  `protobuf:"bytes,5,opt,name=ProveValue" json:"ProveValue,omitempty"`
	TotalQN          *uint64 `protobuf:"varint,6,opt,name=TotalQN" json:"TotalQN,omitempty"`
	CurTime          []byte  `protobuf:"bytes,7,opt,name=CurTime" json:"CurTime,omitempty"`
	Castor           []byte  `protobuf:"bytes,8,opt,name=Castor" json:"Castor,omitempty"`
	GroupId          []byte  `protobuf:"bytes,9,opt,name=GroupId" json:"GroupId,omitempty"`
	Signature        []byte  `protobuf:"bytes,10,opt,name=Signature" json:"Signature,omitempty"`
	Nonce            *uint64 `protobuf:"varint,11,opt,name=Nonce" json:"Nonce,omitempty"`
	Transactions     *Hashes `protobuf:"bytes,12,opt,name=transactions" json:"transactions,omitempty"`
	TxTree           []byte  `protobuf:"bytes,13,opt,name=TxTree" json:"TxTree,omitempty"`
	ReceiptTree      []byte  `protobuf:"bytes,14,opt,name=ReceiptTree" json:"ReceiptTree,omitempty"`
	StateTree        []byte  `protobuf:"bytes,15,opt,name=StateTree" json:"StateTree,omitempty"`
	ExtraData        []byte  `protobuf:"bytes,16,opt,name=ExtraData" json:"ExtraData,omitempty"`
	Random           []byte  `protobuf:"bytes,17,opt,name=Random" json:"Random,omitempty"`
	ProveRoot        []byte  `protobuf:"bytes,18,opt,name=ProveRoot" json:"ProveRoot,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BlockHeader) Reset()                    { *m = BlockHeader{} }
func (m *BlockHeader) String() string            { return proto.CompactTextString(m) }
func (*BlockHeader) ProtoMessage()               {}
func (*BlockHeader) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{6} }

func (m *BlockHeader) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *BlockHeader) GetHeight() uint64 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

func (m *BlockHeader) GetPreHash() []byte {
	if m != nil {
		return m.PreHash
	}
	return nil
}

func (m *BlockHeader) GetPreTime() []byte {
	if m != nil {
		return m.PreTime
	}
	return nil
}

func (m *BlockHeader) GetProveValue() []byte {
	if m != nil {
		return m.ProveValue
	}
	return nil
}

func (m *BlockHeader) GetTotalQN() uint64 {
	if m != nil && m.TotalQN != nil {
		return *m.TotalQN
	}
	return 0
}

func (m *BlockHeader) GetCurTime() []byte {
	if m != nil {
		return m.CurTime
	}
	return nil
}

func (m *BlockHeader) GetCastor() []byte {
	if m != nil {
		return m.Castor
	}
	return nil
}

func (m *BlockHeader) GetGroupId() []byte {
	if m != nil {
		return m.GroupId
	}
	return nil
}

func (m *BlockHeader) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *BlockHeader) GetNonce() uint64 {
	if m != nil && m.Nonce != nil {
		return *m.Nonce
	}
	return 0
}

func (m *BlockHeader) GetTransactions() *Hashes {
	if m != nil {
		return m.Transactions
	}
	return nil
}

func (m *BlockHeader) GetTxTree() []byte {
	if m != nil {
		return m.TxTree
	}
	return nil
}

func (m *BlockHeader) GetReceiptTree() []byte {
	if m != nil {
		return m.ReceiptTree
	}
	return nil
}

func (m *BlockHeader) GetStateTree() []byte {
	if m != nil {
		return m.StateTree
	}
	return nil
}

func (m *BlockHeader) GetExtraData() []byte {
	if m != nil {
		return m.ExtraData
	}
	return nil
}

func (m *BlockHeader) GetRandom() []byte {
	if m != nil {
		return m.Random
	}
	return nil
}

func (m *BlockHeader) GetProveRoot() []byte {
	if m != nil {
		return m.ProveRoot
	}
	return nil
}

type BlockBody struct {
	BlockHash        []byte         `protobuf:"bytes,1,req,name=BlockHash" json:"BlockHash,omitempty"`
	Transactions     []*Transaction `protobuf:"bytes,2,rep,name=transactions" json:"transactions,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *BlockBody) Reset()                    { *m = BlockBody{} }
func (m *BlockBody) String() string            { return proto.CompactTextString(m) }
func (*BlockBody) ProtoMessage()               {}
func (*BlockBody) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{7} }

func (m *BlockBody) GetBlockHash() []byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

func (m *BlockBody) GetTransactions() []*Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type Block struct {
	Header           *BlockHeader   `protobuf:"bytes,1,req,name=Header" json:"Header,omitempty"`
	Transactions     []*Transaction `protobuf:"bytes,2,rep,name=transactions" json:"transactions,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Block) Reset()                    { *m = Block{} }
func (m *Block) String() string            { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()               {}
func (*Block) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{8} }

func (m *Block) GetHeader() *BlockHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Block) GetTransactions() []*Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type BlockSlice struct {
	Blocks           []*Block `protobuf:"bytes,1,rep,name=Blocks" json:"Blocks,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *BlockSlice) Reset()                    { *m = BlockSlice{} }
func (m *BlockSlice) String() string            { return proto.CompactTextString(m) }
func (*BlockSlice) ProtoMessage()               {}
func (*BlockSlice) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{9} }

func (m *BlockSlice) GetBlocks() []*Block {
	if m != nil {
		return m.Blocks
	}
	return nil
}

type Member struct {
	Id               []byte `protobuf:"bytes,1,req,name=Id" json:"Id,omitempty"`
	PubKey           []byte `protobuf:"bytes,2,req,name=PubKey" json:"PubKey,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Member) Reset()                    { *m = Member{} }
func (m *Member) String() string            { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()               {}
func (*Member) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{10} }

func (m *Member) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Member) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

type GroupHeader struct {
	Hash             []byte  `protobuf:"bytes,1,opt,name=Hash" json:"Hash,omitempty"`
	Parent           []byte  `protobuf:"bytes,2,opt,name=Parent" json:"Parent,omitempty"`
	PreGroup         []byte  `protobuf:"bytes,3,req,name=PreGroup" json:"PreGroup,omitempty"`
	Authority        *uint64 `protobuf:"varint,4,opt,name=Authority" json:"Authority,omitempty"`
	Name             *string `protobuf:"bytes,5,opt,name=Name" json:"Name,omitempty"`
	BeginTime        []byte  `protobuf:"bytes,6,opt,name=BeginTime" json:"BeginTime,omitempty"`
	MemberRoot       []byte  `protobuf:"bytes,7,opt,name=MemberRoot" json:"MemberRoot,omitempty"`
	CreateHeight     *uint64 `protobuf:"varint,8,opt,name=CreateHeight" json:"CreateHeight,omitempty"`
	ReadyHeight      *uint64 `protobuf:"varint,9,opt,name=ReadyHeight" json:"ReadyHeight,omitempty"`
	WorkHeight       *uint64 `protobuf:"varint,10,opt,name=WorkHeight" json:"WorkHeight,omitempty"`
	DismissHeight    *uint64 `protobuf:"varint,11,opt,name=DismissHeight" json:"DismissHeight,omitempty"`
	Extends          *string `protobuf:"bytes,12,opt,name=Extends" json:"Extends,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *GroupHeader) Reset()                    { *m = GroupHeader{} }
func (m *GroupHeader) String() string            { return proto.CompactTextString(m) }
func (*GroupHeader) ProtoMessage()               {}
func (*GroupHeader) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{11} }

func (m *GroupHeader) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *GroupHeader) GetParent() []byte {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *GroupHeader) GetPreGroup() []byte {
	if m != nil {
		return m.PreGroup
	}
	return nil
}

func (m *GroupHeader) GetAuthority() uint64 {
	if m != nil && m.Authority != nil {
		return *m.Authority
	}
	return 0
}

func (m *GroupHeader) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *GroupHeader) GetBeginTime() []byte {
	if m != nil {
		return m.BeginTime
	}
	return nil
}

func (m *GroupHeader) GetMemberRoot() []byte {
	if m != nil {
		return m.MemberRoot
	}
	return nil
}

func (m *GroupHeader) GetCreateHeight() uint64 {
	if m != nil && m.CreateHeight != nil {
		return *m.CreateHeight
	}
	return 0
}

func (m *GroupHeader) GetReadyHeight() uint64 {
	if m != nil && m.ReadyHeight != nil {
		return *m.ReadyHeight
	}
	return 0
}

func (m *GroupHeader) GetWorkHeight() uint64 {
	if m != nil && m.WorkHeight != nil {
		return *m.WorkHeight
	}
	return 0
}

func (m *GroupHeader) GetDismissHeight() uint64 {
	if m != nil && m.DismissHeight != nil {
		return *m.DismissHeight
	}
	return 0
}

func (m *GroupHeader) GetExtends() string {
	if m != nil && m.Extends != nil {
		return *m.Extends
	}
	return ""
}

type Group struct {
	Header           *GroupHeader `protobuf:"bytes,1,req,name=Header" json:"Header,omitempty"`
	Id               []byte       `protobuf:"bytes,2,opt,name=Id" json:"Id,omitempty"`
	PubKey           []byte       `protobuf:"bytes,3,opt,name=PubKey" json:"PubKey,omitempty"`
	Signature        []byte       `protobuf:"bytes,4,opt,name=Signature" json:"Signature,omitempty"`
	Members          [][]byte     `protobuf:"bytes,5,rep,name=Members" json:"Members,omitempty"`
	GroupHeight      *uint64      `protobuf:"varint,6,opt,name=GroupHeight" json:"GroupHeight,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Group) Reset()                    { *m = Group{} }
func (m *Group) String() string            { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()               {}
func (*Group) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{12} }

func (m *Group) GetHeader() *GroupHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Group) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Group) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *Group) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Group) GetMembers() [][]byte {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *Group) GetGroupHeight() uint64 {
	if m != nil && m.GroupHeight != nil {
		return *m.GroupHeight
	}
	return 0
}

type GroupInfo struct {
	Groups           []*Group `protobuf:"bytes,1,rep,name=Groups" json:"Groups,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupInfo) Reset()                    { *m = GroupInfo{} }
func (m *GroupInfo) String() string            { return proto.CompactTextString(m) }
func (*GroupInfo) ProtoMessage()               {}
func (*GroupInfo) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{13} }

func (m *GroupInfo) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type GroupSlice struct {
	Groups           []*Group `protobuf:"bytes,1,rep,name=Groups" json:"Groups,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupSlice) Reset()                    { *m = GroupSlice{} }
func (m *GroupSlice) String() string            { return proto.CompactTextString(m) }
func (*GroupSlice) ProtoMessage()               {}
func (*GroupSlice) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{14} }

func (m *GroupSlice) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type GroupIdSlice struct {
	GroupIds         [][]byte `protobuf:"bytes,1,rep,name=GroupIds" json:"GroupIds,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *GroupIdSlice) Reset()                    { *m = GroupIdSlice{} }
func (m *GroupIdSlice) String() string            { return proto.CompactTextString(m) }
func (*GroupIdSlice) ProtoMessage()               {}
func (*GroupIdSlice) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{15} }

func (m *GroupIdSlice) GetGroupIds() [][]byte {
	if m != nil {
		return m.GroupIds
	}
	return nil
}

type GroupRequestInfo struct {
	CurrentTopGroupId []byte        `protobuf:"bytes,1,req,name=CurrentTopGroupId" json:"CurrentTopGroupId,omitempty"`
	ExistGroupIds     *GroupIdSlice `protobuf:"bytes,2,opt,name=ExistGroupIds" json:"ExistGroupIds,omitempty"`
	XXX_unrecognized  []byte        `json:"-"`
}

func (m *GroupRequestInfo) Reset()                    { *m = GroupRequestInfo{} }
func (m *GroupRequestInfo) String() string            { return proto.CompactTextString(m) }
func (*GroupRequestInfo) ProtoMessage()               {}
func (*GroupRequestInfo) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{16} }

func (m *GroupRequestInfo) GetCurrentTopGroupId() []byte {
	if m != nil {
		return m.CurrentTopGroupId
	}
	return nil
}

func (m *GroupRequestInfo) GetExistGroupIds() *GroupIdSlice {
	if m != nil {
		return m.ExistGroupIds
	}
	return nil
}

type Hashes struct {
	Hashes           [][]byte `protobuf:"bytes,1,rep,name=hashes" json:"hashes,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Hashes) Reset()                    { *m = Hashes{} }
func (m *Hashes) String() string            { return proto.CompactTextString(m) }
func (*Hashes) ProtoMessage()               {}
func (*Hashes) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{17} }

func (m *Hashes) GetHashes() [][]byte {
	if m != nil {
		return m.Hashes
	}
	return nil
}

type TotalQnInfo struct {
	TotalQn          *uint64 `protobuf:"varint,1,req,name=TotalQn" json:"TotalQn,omitempty"`
	Height           *uint64 `protobuf:"varint,2,req,name=Height" json:"Height,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TotalQnInfo) Reset()                    { *m = TotalQnInfo{} }
func (m *TotalQnInfo) String() string            { return proto.CompactTextString(m) }
func (*TotalQnInfo) ProtoMessage()               {}
func (*TotalQnInfo) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{18} }

func (m *TotalQnInfo) GetTotalQn() uint64 {
	if m != nil && m.TotalQn != nil {
		return *m.TotalQn
	}
	return 0
}

func (m *TotalQnInfo) GetHeight() uint64 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

type StateInfoReq struct {
	Height           *uint64           `protobuf:"varint,1,req,name=Height" json:"Height,omitempty"`
	Transactions     *TransactionSlice `protobuf:"bytes,2,opt,name=Transactions" json:"Transactions,omitempty"`
	Addresses        [][]byte          `protobuf:"bytes,3,rep,name=Addresses" json:"Addresses,omitempty"`
	BlockHash        []byte            `protobuf:"bytes,4,req,name=BlockHash" json:"BlockHash,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *StateInfoReq) Reset()                    { *m = StateInfoReq{} }
func (m *StateInfoReq) String() string            { return proto.CompactTextString(m) }
func (*StateInfoReq) ProtoMessage()               {}
func (*StateInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{19} }

func (m *StateInfoReq) GetHeight() uint64 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

func (m *StateInfoReq) GetTransactions() *TransactionSlice {
	if m != nil {
		return m.Transactions
	}
	return nil
}

func (m *StateInfoReq) GetAddresses() [][]byte {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *StateInfoReq) GetBlockHash() []byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

type StateInfo struct {
	Height            *uint64     `protobuf:"varint,1,req,name=Height" json:"Height,omitempty"`
	TrieNodes         []*TrieNode `protobuf:"bytes,2,rep,name=TrieNodes" json:"TrieNodes,omitempty"`
	BlockHash         []byte      `protobuf:"bytes,3,req,name=BlockHash" json:"BlockHash,omitempty"`
	ProBlockStateRoot []byte      `protobuf:"bytes,4,req,name=ProBlockStateRoot" json:"ProBlockStateRoot,omitempty"`
	XXX_unrecognized  []byte      `json:"-"`
}

func (m *StateInfo) Reset()                    { *m = StateInfo{} }
func (m *StateInfo) String() string            { return proto.CompactTextString(m) }
func (*StateInfo) ProtoMessage()               {}
func (*StateInfo) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{20} }

func (m *StateInfo) GetHeight() uint64 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

func (m *StateInfo) GetTrieNodes() []*TrieNode {
	if m != nil {
		return m.TrieNodes
	}
	return nil
}

func (m *StateInfo) GetBlockHash() []byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

func (m *StateInfo) GetProBlockStateRoot() []byte {
	if m != nil {
		return m.ProBlockStateRoot
	}
	return nil
}

type TrieNode struct {
	Key              []byte `protobuf:"bytes,1,req,name=Key" json:"Key,omitempty"`
	Data             []byte `protobuf:"bytes,2,req,name=Data" json:"Data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TrieNode) Reset()                    { *m = TrieNode{} }
func (m *TrieNode) String() string            { return proto.CompactTextString(m) }
func (*TrieNode) ProtoMessage()               {}
func (*TrieNode) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{21} }

func (m *TrieNode) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *TrieNode) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type SignData struct {
	DataHash         []byte `protobuf:"bytes,1,req,name=DataHash" json:"DataHash,omitempty"`
	DataSign         []byte `protobuf:"bytes,2,req,name=DataSign" json:"DataSign,omitempty"`
	SignMember       []byte `protobuf:"bytes,3,req,name=SignMember" json:"SignMember,omitempty"`
	Version          *int32 `protobuf:"varint,4,opt,name=Version,def=0" json:"Version,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SignData) Reset()                    { *m = SignData{} }
func (m *SignData) String() string            { return proto.CompactTextString(m) }
func (*SignData) ProtoMessage()               {}
func (*SignData) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{22} }

const Default_SignData_Version int32 = 0

func (m *SignData) GetDataHash() []byte {
	if m != nil {
		return m.DataHash
	}
	return nil
}

func (m *SignData) GetDataSign() []byte {
	if m != nil {
		return m.DataSign
	}
	return nil
}

func (m *SignData) GetSignMember() []byte {
	if m != nil {
		return m.SignMember
	}
	return nil
}

func (m *SignData) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_SignData_Version
}

type ConsensusGroupInitSummary struct {
	Header           *GroupHeader `protobuf:"bytes,1,req,name=Header" json:"Header,omitempty"`
	Signature        []byte       `protobuf:"bytes,2,req,name=Signature" json:"Signature,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ConsensusGroupInitSummary) Reset()                    { *m = ConsensusGroupInitSummary{} }
func (m *ConsensusGroupInitSummary) String() string            { return proto.CompactTextString(m) }
func (*ConsensusGroupInitSummary) ProtoMessage()               {}
func (*ConsensusGroupInitSummary) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{23} }

func (m *ConsensusGroupInitSummary) GetHeader() *GroupHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ConsensusGroupInitSummary) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type PubKeyInfo struct {
	ID               []byte `protobuf:"bytes,1,req,name=ID" json:"ID,omitempty"`
	PublicKey        []byte `protobuf:"bytes,2,req,name=PublicKey" json:"PublicKey,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PubKeyInfo) Reset()                    { *m = PubKeyInfo{} }
func (m *PubKeyInfo) String() string            { return proto.CompactTextString(m) }
func (*PubKeyInfo) ProtoMessage()               {}
func (*PubKeyInfo) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{24} }

func (m *PubKeyInfo) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *PubKeyInfo) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type ConsensusGroupInitInfo struct {
	GI               *ConsensusGroupInitSummary `protobuf:"bytes,1,req,name=GI" json:"GI,omitempty"`
	Mems             [][]byte                   `protobuf:"bytes,2,rep,name=Mems" json:"Mems,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *ConsensusGroupInitInfo) Reset()                    { *m = ConsensusGroupInitInfo{} }
func (m *ConsensusGroupInitInfo) String() string            { return proto.CompactTextString(m) }
func (*ConsensusGroupInitInfo) ProtoMessage()               {}
func (*ConsensusGroupInitInfo) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{25} }

func (m *ConsensusGroupInitInfo) GetGI() *ConsensusGroupInitSummary {
	if m != nil {
		return m.GI
	}
	return nil
}

func (m *ConsensusGroupInitInfo) GetMems() [][]byte {
	if m != nil {
		return m.Mems
	}
	return nil
}

type ConsensusGroupRawMessage struct {
	GInfo            *ConsensusGroupInitInfo `protobuf:"bytes,1,req,name=GInfo" json:"GInfo,omitempty"`
	Sign             *SignData               `protobuf:"bytes,3,req,name=sign" json:"sign,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *ConsensusGroupRawMessage) Reset()                    { *m = ConsensusGroupRawMessage{} }
func (m *ConsensusGroupRawMessage) String() string            { return proto.CompactTextString(m) }
func (*ConsensusGroupRawMessage) ProtoMessage()               {}
func (*ConsensusGroupRawMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{26} }

func (m *ConsensusGroupRawMessage) GetGInfo() *ConsensusGroupInitInfo {
	if m != nil {
		return m.GInfo
	}
	return nil
}

func (m *ConsensusGroupRawMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

type SharePiece struct {
	Seckey           []byte `protobuf:"bytes,1,req,name=Seckey" json:"Seckey,omitempty"`
	Pubkey           []byte `protobuf:"bytes,2,req,name=Pubkey" json:"Pubkey,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SharePiece) Reset()                    { *m = SharePiece{} }
func (m *SharePiece) String() string            { return proto.CompactTextString(m) }
func (*SharePiece) ProtoMessage()               {}
func (*SharePiece) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{27} }

func (m *SharePiece) GetSeckey() []byte {
	if m != nil {
		return m.Seckey
	}
	return nil
}

func (m *SharePiece) GetPubkey() []byte {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

type ConsensusSharePieceMessage struct {
	GHash            []byte      `protobuf:"bytes,1,req,name=GHash" json:"GHash,omitempty"`
	Dest             []byte      `protobuf:"bytes,2,req,name=Dest" json:"Dest,omitempty"`
	SharePiece       *SharePiece `protobuf:"bytes,3,req,name=SharePiece" json:"SharePiece,omitempty"`
	MemCnt           *int32      `protobuf:"varint,4,req,name=MemCnt" json:"MemCnt,omitempty"`
	Sign             *SignData   `protobuf:"bytes,5,req,name=Sign" json:"Sign,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *ConsensusSharePieceMessage) Reset()                    { *m = ConsensusSharePieceMessage{} }
func (m *ConsensusSharePieceMessage) String() string            { return proto.CompactTextString(m) }
func (*ConsensusSharePieceMessage) ProtoMessage()               {}
func (*ConsensusSharePieceMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{28} }

func (m *ConsensusSharePieceMessage) GetGHash() []byte {
	if m != nil {
		return m.GHash
	}
	return nil
}

func (m *ConsensusSharePieceMessage) GetDest() []byte {
	if m != nil {
		return m.Dest
	}
	return nil
}

func (m *ConsensusSharePieceMessage) GetSharePiece() *SharePiece {
	if m != nil {
		return m.SharePiece
	}
	return nil
}

func (m *ConsensusSharePieceMessage) GetMemCnt() int32 {
	if m != nil && m.MemCnt != nil {
		return *m.MemCnt
	}
	return 0
}

func (m *ConsensusSharePieceMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

type ConsensusSignPubKeyMessage struct {
	GHash            []byte    `protobuf:"bytes,1,req,name=GHash" json:"GHash,omitempty"`
	GroupID          []byte    `protobuf:"bytes,2,req,name=GroupID" json:"GroupID,omitempty"`
	SignPK           []byte    `protobuf:"bytes,3,req,name=SignPK" json:"SignPK,omitempty"`
	MemCnt           *int32    `protobuf:"varint,4,req,name=MemCnt" json:"MemCnt,omitempty"`
	SignData         *SignData `protobuf:"bytes,5,req,name=SignData" json:"SignData,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ConsensusSignPubKeyMessage) Reset()                    { *m = ConsensusSignPubKeyMessage{} }
func (m *ConsensusSignPubKeyMessage) String() string            { return proto.CompactTextString(m) }
func (*ConsensusSignPubKeyMessage) ProtoMessage()               {}
func (*ConsensusSignPubKeyMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{29} }

func (m *ConsensusSignPubKeyMessage) GetGHash() []byte {
	if m != nil {
		return m.GHash
	}
	return nil
}

func (m *ConsensusSignPubKeyMessage) GetGroupID() []byte {
	if m != nil {
		return m.GroupID
	}
	return nil
}

func (m *ConsensusSignPubKeyMessage) GetSignPK() []byte {
	if m != nil {
		return m.SignPK
	}
	return nil
}

func (m *ConsensusSignPubKeyMessage) GetMemCnt() int32 {
	if m != nil && m.MemCnt != nil {
		return *m.MemCnt
	}
	return 0
}

func (m *ConsensusSignPubKeyMessage) GetSignData() *SignData {
	if m != nil {
		return m.SignData
	}
	return nil
}

type ConsensusSignPubkeyReqMessage struct {
	GroupID          []byte    `protobuf:"bytes,1,req,name=GroupID" json:"GroupID,omitempty"`
	SignData         *SignData `protobuf:"bytes,2,req,name=SignData" json:"SignData,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ConsensusSignPubkeyReqMessage) Reset()         { *m = ConsensusSignPubkeyReqMessage{} }
func (m *ConsensusSignPubkeyReqMessage) String() string { return proto.CompactTextString(m) }
func (*ConsensusSignPubkeyReqMessage) ProtoMessage()    {}
func (*ConsensusSignPubkeyReqMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorTas, []int{30}
}

func (m *ConsensusSignPubkeyReqMessage) GetGroupID() []byte {
	if m != nil {
		return m.GroupID
	}
	return nil
}

func (m *ConsensusSignPubkeyReqMessage) GetSignData() *SignData {
	if m != nil {
		return m.SignData
	}
	return nil
}

type StaticGroupSummary struct {
	GroupID          []byte `protobuf:"bytes,1,req,name=GroupID" json:"GroupID,omitempty"`
	GroupPK          []byte `protobuf:"bytes,2,req,name=GroupPK" json:"GroupPK,omitempty"`
	GHash            []byte `protobuf:"bytes,3,req,name=GHash" json:"GHash,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *StaticGroupSummary) Reset()                    { *m = StaticGroupSummary{} }
func (m *StaticGroupSummary) String() string            { return proto.CompactTextString(m) }
func (*StaticGroupSummary) ProtoMessage()               {}
func (*StaticGroupSummary) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{31} }

func (m *StaticGroupSummary) GetGroupID() []byte {
	if m != nil {
		return m.GroupID
	}
	return nil
}

func (m *StaticGroupSummary) GetGroupPK() []byte {
	if m != nil {
		return m.GroupPK
	}
	return nil
}

func (m *StaticGroupSummary) GetGHash() []byte {
	if m != nil {
		return m.GHash
	}
	return nil
}

type ConsensusGroupInitedMessage struct {
	GHash            []byte    `protobuf:"bytes,1,req,name=GHash" json:"GHash,omitempty"`
	GroupID          []byte    `protobuf:"bytes,2,req,name=GroupID" json:"GroupID,omitempty"`
	GroupPK          []byte    `protobuf:"bytes,3,req,name=GroupPK" json:"GroupPK,omitempty"`
	CreateHeight     *uint64   `protobuf:"varint,4,req,name=CreateHeight" json:"CreateHeight,omitempty"`
	ParentSign       []byte    `protobuf:"bytes,5,req,name=ParentSign" json:"ParentSign,omitempty"`
	MemMask          []byte    `protobuf:"bytes,6,req,name=MemMask" json:"MemMask,omitempty"`
	MemCnt           *int32    `protobuf:"varint,7,req,name=MemCnt" json:"MemCnt,omitempty"`
	Sign             *SignData `protobuf:"bytes,8,req,name=Sign" json:"Sign,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ConsensusGroupInitedMessage) Reset()                    { *m = ConsensusGroupInitedMessage{} }
func (m *ConsensusGroupInitedMessage) String() string            { return proto.CompactTextString(m) }
func (*ConsensusGroupInitedMessage) ProtoMessage()               {}
func (*ConsensusGroupInitedMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{32} }

func (m *ConsensusGroupInitedMessage) GetGHash() []byte {
	if m != nil {
		return m.GHash
	}
	return nil
}

func (m *ConsensusGroupInitedMessage) GetGroupID() []byte {
	if m != nil {
		return m.GroupID
	}
	return nil
}

func (m *ConsensusGroupInitedMessage) GetGroupPK() []byte {
	if m != nil {
		return m.GroupPK
	}
	return nil
}

func (m *ConsensusGroupInitedMessage) GetCreateHeight() uint64 {
	if m != nil && m.CreateHeight != nil {
		return *m.CreateHeight
	}
	return 0
}

func (m *ConsensusGroupInitedMessage) GetParentSign() []byte {
	if m != nil {
		return m.ParentSign
	}
	return nil
}

func (m *ConsensusGroupInitedMessage) GetMemMask() []byte {
	if m != nil {
		return m.MemMask
	}
	return nil
}

func (m *ConsensusGroupInitedMessage) GetMemCnt() int32 {
	if m != nil && m.MemCnt != nil {
		return *m.MemCnt
	}
	return 0
}

func (m *ConsensusGroupInitedMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

type ConsensusCurrentMessage struct {
	GroupID          []byte    `protobuf:"bytes,1,opt,name=GroupID" json:"GroupID,omitempty"`
	PreHash          []byte    `protobuf:"bytes,2,req,name=PreHash" json:"PreHash,omitempty"`
	PreTime          []byte    `protobuf:"bytes,3,req,name=PreTime" json:"PreTime,omitempty"`
	BlockHeight      *uint64   `protobuf:"varint,4,req,name=BlockHeight" json:"BlockHeight,omitempty"`
	Sign             *SignData `protobuf:"bytes,6,req,name=Sign" json:"Sign,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ConsensusCurrentMessage) Reset()                    { *m = ConsensusCurrentMessage{} }
func (m *ConsensusCurrentMessage) String() string            { return proto.CompactTextString(m) }
func (*ConsensusCurrentMessage) ProtoMessage()               {}
func (*ConsensusCurrentMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{33} }

func (m *ConsensusCurrentMessage) GetGroupID() []byte {
	if m != nil {
		return m.GroupID
	}
	return nil
}

func (m *ConsensusCurrentMessage) GetPreHash() []byte {
	if m != nil {
		return m.PreHash
	}
	return nil
}

func (m *ConsensusCurrentMessage) GetPreTime() []byte {
	if m != nil {
		return m.PreTime
	}
	return nil
}

func (m *ConsensusCurrentMessage) GetBlockHeight() uint64 {
	if m != nil && m.BlockHeight != nil {
		return *m.BlockHeight
	}
	return 0
}

func (m *ConsensusCurrentMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

type ConsensusCastMessage struct {
	Bh               *BlockHeader `protobuf:"bytes,1,req,name=Bh" json:"Bh,omitempty"`
	GroupID          []byte       `protobuf:"bytes,2,opt,name=GroupID" json:"GroupID,omitempty"`
	Sign             *SignData    `protobuf:"bytes,3,req,name=Sign" json:"Sign,omitempty"`
	ProveHash        [][]byte     `protobuf:"bytes,4,rep,name=ProveHash" json:"ProveHash,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ConsensusCastMessage) Reset()                    { *m = ConsensusCastMessage{} }
func (m *ConsensusCastMessage) String() string            { return proto.CompactTextString(m) }
func (*ConsensusCastMessage) ProtoMessage()               {}
func (*ConsensusCastMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{34} }

func (m *ConsensusCastMessage) GetBh() *BlockHeader {
	if m != nil {
		return m.Bh
	}
	return nil
}

func (m *ConsensusCastMessage) GetGroupID() []byte {
	if m != nil {
		return m.GroupID
	}
	return nil
}

func (m *ConsensusCastMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

func (m *ConsensusCastMessage) GetProveHash() [][]byte {
	if m != nil {
		return m.ProveHash
	}
	return nil
}

type ConsensusVerifyMessage struct {
	BlockHash        []byte    `protobuf:"bytes,1,req,name=BlockHash" json:"BlockHash,omitempty"`
	RandomSign       []byte    `protobuf:"bytes,2,req,name=RandomSign" json:"RandomSign,omitempty"`
	Sign             *SignData `protobuf:"bytes,3,req,name=Sign" json:"Sign,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ConsensusVerifyMessage) Reset()                    { *m = ConsensusVerifyMessage{} }
func (m *ConsensusVerifyMessage) String() string            { return proto.CompactTextString(m) }
func (*ConsensusVerifyMessage) ProtoMessage()               {}
func (*ConsensusVerifyMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{35} }

func (m *ConsensusVerifyMessage) GetBlockHash() []byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

func (m *ConsensusVerifyMessage) GetRandomSign() []byte {
	if m != nil {
		return m.RandomSign
	}
	return nil
}

func (m *ConsensusVerifyMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

type ConsensusBlockMessage struct {
	Block            *Block `protobuf:"bytes,1,req,name=Block" json:"Block,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ConsensusBlockMessage) Reset()                    { *m = ConsensusBlockMessage{} }
func (m *ConsensusBlockMessage) String() string            { return proto.CompactTextString(m) }
func (*ConsensusBlockMessage) ProtoMessage()               {}
func (*ConsensusBlockMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{36} }

func (m *ConsensusBlockMessage) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

type ConsensusCreateGroupRawMessage struct {
	GInfo            *ConsensusGroupInitInfo `protobuf:"bytes,1,req,name=GInfo" json:"GInfo,omitempty"`
	Sign             *SignData               `protobuf:"bytes,2,req,name=sign" json:"sign,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *ConsensusCreateGroupRawMessage) Reset()         { *m = ConsensusCreateGroupRawMessage{} }
func (m *ConsensusCreateGroupRawMessage) String() string { return proto.CompactTextString(m) }
func (*ConsensusCreateGroupRawMessage) ProtoMessage()    {}
func (*ConsensusCreateGroupRawMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorTas, []int{37}
}

func (m *ConsensusCreateGroupRawMessage) GetGInfo() *ConsensusGroupInitInfo {
	if m != nil {
		return m.GInfo
	}
	return nil
}

func (m *ConsensusCreateGroupRawMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

type ConsensusCreateGroupSignMessage struct {
	GHash            []byte    `protobuf:"bytes,1,req,name=GHash" json:"GHash,omitempty"`
	Sign             *SignData `protobuf:"bytes,2,req,name=sign" json:"sign,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ConsensusCreateGroupSignMessage) Reset()         { *m = ConsensusCreateGroupSignMessage{} }
func (m *ConsensusCreateGroupSignMessage) String() string { return proto.CompactTextString(m) }
func (*ConsensusCreateGroupSignMessage) ProtoMessage()    {}
func (*ConsensusCreateGroupSignMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorTas, []int{38}
}

func (m *ConsensusCreateGroupSignMessage) GetGHash() []byte {
	if m != nil {
		return m.GHash
	}
	return nil
}

func (m *ConsensusCreateGroupSignMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

type Bonus struct {
	TxHash           []byte  `protobuf:"bytes,1,req,name=TxHash" json:"TxHash,omitempty"`
	TargetIds        []int32 `protobuf:"varint,2,rep,name=TargetIds" json:"TargetIds,omitempty"`
	BlockHash        []byte  `protobuf:"bytes,3,req,name=BlockHash" json:"BlockHash,omitempty"`
	GroupId          []byte  `protobuf:"bytes,4,req,name=GroupId" json:"GroupId,omitempty"`
	Sign             []byte  `protobuf:"bytes,5,opt,name=Sign" json:"Sign,omitempty"`
	TotalValue       *uint64 `protobuf:"varint,6,req,name=TotalValue" json:"TotalValue,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Bonus) Reset()                    { *m = Bonus{} }
func (m *Bonus) String() string            { return proto.CompactTextString(m) }
func (*Bonus) ProtoMessage()               {}
func (*Bonus) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{39} }

func (m *Bonus) GetTxHash() []byte {
	if m != nil {
		return m.TxHash
	}
	return nil
}

func (m *Bonus) GetTargetIds() []int32 {
	if m != nil {
		return m.TargetIds
	}
	return nil
}

func (m *Bonus) GetBlockHash() []byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

func (m *Bonus) GetGroupId() []byte {
	if m != nil {
		return m.GroupId
	}
	return nil
}

func (m *Bonus) GetSign() []byte {
	if m != nil {
		return m.Sign
	}
	return nil
}

func (m *Bonus) GetTotalValue() uint64 {
	if m != nil && m.TotalValue != nil {
		return *m.TotalValue
	}
	return 0
}

type CastRewardTransSignReqMessage struct {
	Sign             *SignData `protobuf:"bytes,1,req,name=Sign" json:"Sign,omitempty"`
	Reward           *Bonus    `protobuf:"bytes,2,req,name=Reward" json:"Reward,omitempty"`
	SignedPieces     [][]byte  `protobuf:"bytes,3,rep,name=SignedPieces" json:"SignedPieces,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *CastRewardTransSignReqMessage) Reset()         { *m = CastRewardTransSignReqMessage{} }
func (m *CastRewardTransSignReqMessage) String() string { return proto.CompactTextString(m) }
func (*CastRewardTransSignReqMessage) ProtoMessage()    {}
func (*CastRewardTransSignReqMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorTas, []int{40}
}

func (m *CastRewardTransSignReqMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

func (m *CastRewardTransSignReqMessage) GetReward() *Bonus {
	if m != nil {
		return m.Reward
	}
	return nil
}

func (m *CastRewardTransSignReqMessage) GetSignedPieces() [][]byte {
	if m != nil {
		return m.SignedPieces
	}
	return nil
}

type CastRewardTransSignMessage struct {
	Sign             *SignData `protobuf:"bytes,1,req,name=Sign" json:"Sign,omitempty"`
	ReqHash          []byte    `protobuf:"bytes,2,req,name=ReqHash" json:"ReqHash,omitempty"`
	BlockHash        []byte    `protobuf:"bytes,3,req,name=BlockHash" json:"BlockHash,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *CastRewardTransSignMessage) Reset()                    { *m = CastRewardTransSignMessage{} }
func (m *CastRewardTransSignMessage) String() string            { return proto.CompactTextString(m) }
func (*CastRewardTransSignMessage) ProtoMessage()               {}
func (*CastRewardTransSignMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{41} }

func (m *CastRewardTransSignMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

func (m *CastRewardTransSignMessage) GetReqHash() []byte {
	if m != nil {
		return m.ReqHash
	}
	return nil
}

func (m *CastRewardTransSignMessage) GetBlockHash() []byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

type TopBlockInfo struct {
	Hash             []byte  `protobuf:"bytes,1,req,name=Hash" json:"Hash,omitempty"`
	TotalQn          *uint64 `protobuf:"varint,2,req,name=TotalQn" json:"TotalQn,omitempty"`
	Height           *uint64 `protobuf:"varint,3,req,name=Height" json:"Height,omitempty"`
	PreHash          []byte  `protobuf:"bytes,4,req,name=PreHash" json:"PreHash,omitempty"`
	ShrinkPV         *uint64 `protobuf:"varint,5,req,name=ShrinkPV" json:"ShrinkPV,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TopBlockInfo) Reset()                    { *m = TopBlockInfo{} }
func (m *TopBlockInfo) String() string            { return proto.CompactTextString(m) }
func (*TopBlockInfo) ProtoMessage()               {}
func (*TopBlockInfo) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{42} }

func (m *TopBlockInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *TopBlockInfo) GetTotalQn() uint64 {
	if m != nil && m.TotalQn != nil {
		return *m.TotalQn
	}
	return 0
}

func (m *TopBlockInfo) GetHeight() uint64 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

func (m *TopBlockInfo) GetPreHash() []byte {
	if m != nil {
		return m.PreHash
	}
	return nil
}

func (m *TopBlockInfo) GetShrinkPV() uint64 {
	if m != nil && m.ShrinkPV != nil {
		return *m.ShrinkPV
	}
	return 0
}

type BlockResponseMsg struct {
	Blocks           []*Block `protobuf:"bytes,1,rep,name=Blocks" json:"Blocks,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *BlockResponseMsg) Reset()                    { *m = BlockResponseMsg{} }
func (m *BlockResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*BlockResponseMsg) ProtoMessage()               {}
func (*BlockResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{43} }

func (m *BlockResponseMsg) GetBlocks() []*Block {
	if m != nil {
		return m.Blocks
	}
	return nil
}

type ChainPieceBlockMsg struct {
	TopHeader        *BlockHeader `protobuf:"bytes,1,req,name=TopHeader" json:"TopHeader,omitempty"`
	Blocks           []*Block     `protobuf:"bytes,2,rep,name=Blocks" json:"Blocks,omitempty"`
	FindAncestor     *bool        `protobuf:"varint,3,req,name=FindAncestor" json:"FindAncestor,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *ChainPieceBlockMsg) Reset()                    { *m = ChainPieceBlockMsg{} }
func (m *ChainPieceBlockMsg) String() string            { return proto.CompactTextString(m) }
func (*ChainPieceBlockMsg) ProtoMessage()               {}
func (*ChainPieceBlockMsg) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{44} }

func (m *ChainPieceBlockMsg) GetTopHeader() *BlockHeader {
	if m != nil {
		return m.TopHeader
	}
	return nil
}

func (m *ChainPieceBlockMsg) GetBlocks() []*Block {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *ChainPieceBlockMsg) GetFindAncestor() bool {
	if m != nil && m.FindAncestor != nil {
		return *m.FindAncestor
	}
	return false
}

type CreateGroupPingMessage struct {
	FromGroupID      []byte    `protobuf:"bytes,1,req,name=FromGroupID" json:"FromGroupID,omitempty"`
	PingID           *string   `protobuf:"bytes,2,req,name=PingID" json:"PingID,omitempty"`
	BaseHeight       *uint64   `protobuf:"varint,3,req,name=BaseHeight" json:"BaseHeight,omitempty"`
	Sign             *SignData `protobuf:"bytes,4,req,name=Sign" json:"Sign,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *CreateGroupPingMessage) Reset()                    { *m = CreateGroupPingMessage{} }
func (m *CreateGroupPingMessage) String() string            { return proto.CompactTextString(m) }
func (*CreateGroupPingMessage) ProtoMessage()               {}
func (*CreateGroupPingMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{45} }

func (m *CreateGroupPingMessage) GetFromGroupID() []byte {
	if m != nil {
		return m.FromGroupID
	}
	return nil
}

func (m *CreateGroupPingMessage) GetPingID() string {
	if m != nil && m.PingID != nil {
		return *m.PingID
	}
	return ""
}

func (m *CreateGroupPingMessage) GetBaseHeight() uint64 {
	if m != nil && m.BaseHeight != nil {
		return *m.BaseHeight
	}
	return 0
}

func (m *CreateGroupPingMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

type CreateGroupPongMessage struct {
	PingID           *string   `protobuf:"bytes,1,req,name=PingID" json:"PingID,omitempty"`
	Ts               []byte    `protobuf:"bytes,2,req,name=Ts" json:"Ts,omitempty"`
	Sign             *SignData `protobuf:"bytes,3,req,name=Sign" json:"Sign,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *CreateGroupPongMessage) Reset()                    { *m = CreateGroupPongMessage{} }
func (m *CreateGroupPongMessage) String() string            { return proto.CompactTextString(m) }
func (*CreateGroupPongMessage) ProtoMessage()               {}
func (*CreateGroupPongMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{46} }

func (m *CreateGroupPongMessage) GetPingID() string {
	if m != nil && m.PingID != nil {
		return *m.PingID
	}
	return ""
}

func (m *CreateGroupPongMessage) GetTs() []byte {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *CreateGroupPongMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

type ReqSharePieceMessage struct {
	GHash            []byte    `protobuf:"bytes,1,req,name=GHash" json:"GHash,omitempty"`
	Sign             *SignData `protobuf:"bytes,2,req,name=Sign" json:"Sign,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ReqSharePieceMessage) Reset()                    { *m = ReqSharePieceMessage{} }
func (m *ReqSharePieceMessage) String() string            { return proto.CompactTextString(m) }
func (*ReqSharePieceMessage) ProtoMessage()               {}
func (*ReqSharePieceMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{47} }

func (m *ReqSharePieceMessage) GetGHash() []byte {
	if m != nil {
		return m.GHash
	}
	return nil
}

func (m *ReqSharePieceMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

type ResponseSharePieceMessage struct {
	GHash            []byte      `protobuf:"bytes,1,req,name=GHash" json:"GHash,omitempty"`
	SharePiece       *SharePiece `protobuf:"bytes,2,req,name=SharePiece" json:"SharePiece,omitempty"`
	Sign             *SignData   `protobuf:"bytes,3,req,name=Sign" json:"Sign,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *ResponseSharePieceMessage) Reset()                    { *m = ResponseSharePieceMessage{} }
func (m *ResponseSharePieceMessage) String() string            { return proto.CompactTextString(m) }
func (*ResponseSharePieceMessage) ProtoMessage()               {}
func (*ResponseSharePieceMessage) Descriptor() ([]byte, []int) { return fileDescriptorTas, []int{48} }

func (m *ResponseSharePieceMessage) GetGHash() []byte {
	if m != nil {
		return m.GHash
	}
	return nil
}

func (m *ResponseSharePieceMessage) GetSharePiece() *SharePiece {
	if m != nil {
		return m.SharePiece
	}
	return nil
}

func (m *ResponseSharePieceMessage) GetSign() *SignData {
	if m != nil {
		return m.Sign
	}
	return nil
}

func init() {
	proto.RegisterType((*Message)(nil), "tas.middleware.pb.Message")
	proto.RegisterType((*Transaction)(nil), "tas.middleware.pb.Transaction")
	proto.RegisterType((*TransactionRequestMessage)(nil), "tas.middleware.pb.TransactionRequestMessage")
	proto.RegisterType((*TrieNodes)(nil), "tas.middleware.pb.TrieNodes")
	proto.RegisterType((*TransactionSlice)(nil), "tas.middleware.pb.TransactionSlice")
	proto.RegisterType((*ChainPieceInfo)(nil), "tas.middleware.pb.ChainPieceInfo")
	proto.RegisterType((*BlockHeader)(nil), "tas.middleware.pb.BlockHeader")
	proto.RegisterType((*BlockBody)(nil), "tas.middleware.pb.BlockBody")
	proto.RegisterType((*Block)(nil), "tas.middleware.pb.Block")
	proto.RegisterType((*BlockSlice)(nil), "tas.middleware.pb.BlockSlice")
	proto.RegisterType((*Member)(nil), "tas.middleware.pb.Member")
	proto.RegisterType((*GroupHeader)(nil), "tas.middleware.pb.GroupHeader")
	proto.RegisterType((*Group)(nil), "tas.middleware.pb.Group")
	proto.RegisterType((*GroupInfo)(nil), "tas.middleware.pb.GroupInfo")
	proto.RegisterType((*GroupSlice)(nil), "tas.middleware.pb.GroupSlice")
	proto.RegisterType((*GroupIdSlice)(nil), "tas.middleware.pb.GroupIdSlice")
	proto.RegisterType((*GroupRequestInfo)(nil), "tas.middleware.pb.GroupRequestInfo")
	proto.RegisterType((*Hashes)(nil), "tas.middleware.pb.Hashes")
	proto.RegisterType((*TotalQnInfo)(nil), "tas.middleware.pb.TotalQnInfo")
	proto.RegisterType((*StateInfoReq)(nil), "tas.middleware.pb.StateInfoReq")
	proto.RegisterType((*StateInfo)(nil), "tas.middleware.pb.StateInfo")
	proto.RegisterType((*TrieNode)(nil), "tas.middleware.pb.TrieNode")
	proto.RegisterType((*SignData)(nil), "tas.middleware.pb.SignData")
	proto.RegisterType((*ConsensusGroupInitSummary)(nil), "tas.middleware.pb.ConsensusGroupInitSummary")
	proto.RegisterType((*PubKeyInfo)(nil), "tas.middleware.pb.PubKeyInfo")
	proto.RegisterType((*ConsensusGroupInitInfo)(nil), "tas.middleware.pb.ConsensusGroupInitInfo")
	proto.RegisterType((*ConsensusGroupRawMessage)(nil), "tas.middleware.pb.ConsensusGroupRawMessage")
	proto.RegisterType((*SharePiece)(nil), "tas.middleware.pb.SharePiece")
	proto.RegisterType((*ConsensusSharePieceMessage)(nil), "tas.middleware.pb.ConsensusSharePieceMessage")
	proto.RegisterType((*ConsensusSignPubKeyMessage)(nil), "tas.middleware.pb.ConsensusSignPubKeyMessage")
	proto.RegisterType((*ConsensusSignPubkeyReqMessage)(nil), "tas.middleware.pb.ConsensusSignPubkeyReqMessage")
	proto.RegisterType((*StaticGroupSummary)(nil), "tas.middleware.pb.StaticGroupSummary")
	proto.RegisterType((*ConsensusGroupInitedMessage)(nil), "tas.middleware.pb.ConsensusGroupInitedMessage")
	proto.RegisterType((*ConsensusCurrentMessage)(nil), "tas.middleware.pb.ConsensusCurrentMessage")
	proto.RegisterType((*ConsensusCastMessage)(nil), "tas.middleware.pb.ConsensusCastMessage")
	proto.RegisterType((*ConsensusVerifyMessage)(nil), "tas.middleware.pb.ConsensusVerifyMessage")
	proto.RegisterType((*ConsensusBlockMessage)(nil), "tas.middleware.pb.ConsensusBlockMessage")
	proto.RegisterType((*ConsensusCreateGroupRawMessage)(nil), "tas.middleware.pb.ConsensusCreateGroupRawMessage")
	proto.RegisterType((*ConsensusCreateGroupSignMessage)(nil), "tas.middleware.pb.ConsensusCreateGroupSignMessage")
	proto.RegisterType((*Bonus)(nil), "tas.middleware.pb.Bonus")
	proto.RegisterType((*CastRewardTransSignReqMessage)(nil), "tas.middleware.pb.CastRewardTransSignReqMessage")
	proto.RegisterType((*CastRewardTransSignMessage)(nil), "tas.middleware.pb.CastRewardTransSignMessage")
	proto.RegisterType((*TopBlockInfo)(nil), "tas.middleware.pb.TopBlockInfo")
	proto.RegisterType((*BlockResponseMsg)(nil), "tas.middleware.pb.BlockResponseMsg")
	proto.RegisterType((*ChainPieceBlockMsg)(nil), "tas.middleware.pb.ChainPieceBlockMsg")
	proto.RegisterType((*CreateGroupPingMessage)(nil), "tas.middleware.pb.CreateGroupPingMessage")
	proto.RegisterType((*CreateGroupPongMessage)(nil), "tas.middleware.pb.CreateGroupPongMessage")
	proto.RegisterType((*ReqSharePieceMessage)(nil), "tas.middleware.pb.ReqSharePieceMessage")
	proto.RegisterType((*ResponseSharePieceMessage)(nil), "tas.middleware.pb.ResponseSharePieceMessage")
}
func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Code))
	}
	if m.Signature != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.Body != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Value != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Value))
	}
	if m.Nonce == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Nonce))
	}
	if m.Target != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.GasLimit == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.GasLimit))
	}
	if m.GasPrice == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.GasPrice))
	}
	if m.Hash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.ExtraData != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.ExtraData)))
		i += copy(dAtA[i:], m.ExtraData)
	}
	if m.ExtraDataType != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.ExtraDataType))
	}
	if m.Type == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Type))
	}
	if m.Sign != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Sign)))
		i += copy(dAtA[i:], m.Sign)
	}
	if m.TargetAccount != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(*m.TargetAccount)))
		i += copy(dAtA[i:], *m.TargetAccount)
	}
	if m.SourceAccount != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(*m.SourceAccount)))
		i += copy(dAtA[i:], *m.SourceAccount)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionRequestMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionRequestMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TransactionHashes) > 0 {
		for _, b := range m.TransactionHashes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTas(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.CurrentBlockHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.CurrentBlockHash)))
		i += copy(dAtA[i:], m.CurrentBlockHash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrieNodes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrieNodes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TrieNodes) > 0 {
		for _, msg := range m.TrieNodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionSlice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChainPieceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainPieceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pieces) > 0 {
		for _, b := range m.Pieces {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTas(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hash != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.Height != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Height))
	}
	if m.PreHash != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.PreHash)))
		i += copy(dAtA[i:], m.PreHash)
	}
	if m.PreTime != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.PreTime)))
		i += copy(dAtA[i:], m.PreTime)
	}
	if m.ProveValue != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.ProveValue)))
		i += copy(dAtA[i:], m.ProveValue)
	}
	if m.TotalQN != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.TotalQN))
	}
	if m.CurTime != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.CurTime)))
		i += copy(dAtA[i:], m.CurTime)
	}
	if m.Castor != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Castor)))
		i += copy(dAtA[i:], m.Castor)
	}
	if m.GroupId != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GroupId)))
		i += copy(dAtA[i:], m.GroupId)
	}
	if m.Signature != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.Nonce != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Nonce))
	}
	if m.Transactions != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Transactions.Size()))
		n1, err := m.Transactions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.TxTree != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.TxTree)))
		i += copy(dAtA[i:], m.TxTree)
	}
	if m.ReceiptTree != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.ReceiptTree)))
		i += copy(dAtA[i:], m.ReceiptTree)
	}
	if m.StateTree != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.StateTree)))
		i += copy(dAtA[i:], m.StateTree)
	}
	if m.ExtraData != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.ExtraData)))
		i += copy(dAtA[i:], m.ExtraData)
	}
	if m.Random != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Random)))
		i += copy(dAtA[i:], m.Random)
	}
	if m.ProveRoot != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.ProveRoot)))
		i += copy(dAtA[i:], m.ProveRoot)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockBody) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.BlockHash)))
		i += copy(dAtA[i:], m.BlockHash)
	}
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Header.Size()))
		n2, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockSlice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.PubKey == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GroupHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hash != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.Parent != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	if m.PreGroup == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.PreGroup)))
		i += copy(dAtA[i:], m.PreGroup)
	}
	if m.Authority != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Authority))
	}
	if m.Name != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.BeginTime != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.BeginTime)))
		i += copy(dAtA[i:], m.BeginTime)
	}
	if m.MemberRoot != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.MemberRoot)))
		i += copy(dAtA[i:], m.MemberRoot)
	}
	if m.CreateHeight != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.CreateHeight))
	}
	if m.ReadyHeight != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.ReadyHeight))
	}
	if m.WorkHeight != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.WorkHeight))
	}
	if m.DismissHeight != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.DismissHeight))
	}
	if m.Extends != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(*m.Extends)))
		i += copy(dAtA[i:], *m.Extends)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Header.Size()))
		n3, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Id != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.PubKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if m.Signature != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if len(m.Members) > 0 {
		for _, b := range m.Members {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTas(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.GroupHeight != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.GroupHeight))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GroupSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupSlice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GroupIdSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupIdSlice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroupIds) > 0 {
		for _, b := range m.GroupIds {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTas(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GroupRequestInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupRequestInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurrentTopGroupId == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.CurrentTopGroupId)))
		i += copy(dAtA[i:], m.CurrentTopGroupId)
	}
	if m.ExistGroupIds != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.ExistGroupIds.Size()))
		n4, err := m.ExistGroupIds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Hashes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hashes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hashes) > 0 {
		for _, b := range m.Hashes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTas(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TotalQnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalQnInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalQn == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.TotalQn))
	}
	if m.Height == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Height))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StateInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Height == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Height))
	}
	if m.Transactions != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Transactions.Size()))
		n5, err := m.Transactions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Addresses) > 0 {
		for _, b := range m.Addresses {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTas(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.BlockHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.BlockHash)))
		i += copy(dAtA[i:], m.BlockHash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Height == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Height))
	}
	if len(m.TrieNodes) > 0 {
		for _, msg := range m.TrieNodes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BlockHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.BlockHash)))
		i += copy(dAtA[i:], m.BlockHash)
	}
	if m.ProBlockStateRoot == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.ProBlockStateRoot)))
		i += copy(dAtA[i:], m.ProBlockStateRoot)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrieNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrieNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Data == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DataHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.DataHash)))
		i += copy(dAtA[i:], m.DataHash)
	}
	if m.DataSign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.DataSign)))
		i += copy(dAtA[i:], m.DataSign)
	}
	if m.SignMember == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.SignMember)))
		i += copy(dAtA[i:], m.SignMember)
	}
	if m.Version != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Version))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusGroupInitSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusGroupInitSummary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Header.Size()))
		n6, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Signature == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PubKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PubKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.PublicKey == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusGroupInitInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusGroupInitInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GI == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.GI.Size()))
		n7, err := m.GI.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Mems) > 0 {
		for _, b := range m.Mems {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTas(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusGroupRawMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusGroupRawMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GInfo == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.GInfo.Size()))
		n8, err := m.GInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n9, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SharePiece) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SharePiece) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seckey == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Seckey)))
		i += copy(dAtA[i:], m.Seckey)
	}
	if m.Pubkey == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Pubkey)))
		i += copy(dAtA[i:], m.Pubkey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusSharePieceMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusSharePieceMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GHash)))
		i += copy(dAtA[i:], m.GHash)
	}
	if m.Dest == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Dest)))
		i += copy(dAtA[i:], m.Dest)
	}
	if m.SharePiece == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.SharePiece.Size()))
		n10, err := m.SharePiece.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.MemCnt == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.MemCnt))
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n11, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusSignPubKeyMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusSignPubKeyMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GHash)))
		i += copy(dAtA[i:], m.GHash)
	}
	if m.GroupID == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if m.SignPK == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.SignPK)))
		i += copy(dAtA[i:], m.SignPK)
	}
	if m.MemCnt == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.MemCnt))
	}
	if m.SignData == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.SignData.Size()))
		n12, err := m.SignData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusSignPubkeyReqMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusSignPubkeyReqMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupID == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if m.SignData == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.SignData.Size()))
		n13, err := m.SignData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StaticGroupSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticGroupSummary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupID == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if m.GroupPK == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GroupPK)))
		i += copy(dAtA[i:], m.GroupPK)
	}
	if m.GHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GHash)))
		i += copy(dAtA[i:], m.GHash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusGroupInitedMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusGroupInitedMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GHash)))
		i += copy(dAtA[i:], m.GHash)
	}
	if m.GroupID == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if m.GroupPK == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GroupPK)))
		i += copy(dAtA[i:], m.GroupPK)
	}
	if m.CreateHeight == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.CreateHeight))
	}
	if m.ParentSign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.ParentSign)))
		i += copy(dAtA[i:], m.ParentSign)
	}
	if m.MemMask == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.MemMask)))
		i += copy(dAtA[i:], m.MemMask)
	}
	if m.MemCnt == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.MemCnt))
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n14, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusCurrentMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusCurrentMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if m.PreHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.PreHash)))
		i += copy(dAtA[i:], m.PreHash)
	}
	if m.PreTime == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.PreTime)))
		i += copy(dAtA[i:], m.PreTime)
	}
	if m.BlockHeight == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.BlockHeight))
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n15, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusCastMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusCastMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bh == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Bh.Size()))
		n16, err := m.Bh.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.GroupID != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n17, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.ProveHash) > 0 {
		for _, b := range m.ProveHash {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTas(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusVerifyMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusVerifyMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.BlockHash)))
		i += copy(dAtA[i:], m.BlockHash)
	}
	if m.RandomSign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.RandomSign)))
		i += copy(dAtA[i:], m.RandomSign)
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n18, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusBlockMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusBlockMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Block == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Block.Size()))
		n19, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusCreateGroupRawMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusCreateGroupRawMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GInfo == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.GInfo.Size()))
		n20, err := m.GInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n21, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusCreateGroupSignMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusCreateGroupSignMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GHash)))
		i += copy(dAtA[i:], m.GHash)
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n22, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Bonus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bonus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.TxHash)))
		i += copy(dAtA[i:], m.TxHash)
	}
	if len(m.TargetIds) > 0 {
		for _, num := range m.TargetIds {
			dAtA[i] = 0x10
			i++
			i = encodeVarintTas(dAtA, i, uint64(num))
		}
	}
	if m.BlockHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.BlockHash)))
		i += copy(dAtA[i:], m.BlockHash)
	}
	if m.GroupId == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GroupId)))
		i += copy(dAtA[i:], m.GroupId)
	}
	if m.Sign != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Sign)))
		i += copy(dAtA[i:], m.Sign)
	}
	if m.TotalValue == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.TotalValue))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CastRewardTransSignReqMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CastRewardTransSignReqMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n23, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Reward == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Reward.Size()))
		n24, err := m.Reward.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.SignedPieces) > 0 {
		for _, b := range m.SignedPieces {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTas(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CastRewardTransSignMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CastRewardTransSignMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n25, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.ReqHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.ReqHash)))
		i += copy(dAtA[i:], m.ReqHash)
	}
	if m.BlockHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.BlockHash)))
		i += copy(dAtA[i:], m.BlockHash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopBlockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopBlockInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.TotalQn == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.TotalQn))
	}
	if m.Height == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.Height))
	}
	if m.PreHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.PreHash)))
		i += copy(dAtA[i:], m.PreHash)
	}
	if m.ShrinkPV == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.ShrinkPV))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChainPieceBlockMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainPieceBlockMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopHeader == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.TopHeader.Size()))
		n26, err := m.TopHeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTas(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FindAncestor == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		if *m.FindAncestor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateGroupPingMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateGroupPingMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromGroupID == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.FromGroupID)))
		i += copy(dAtA[i:], m.FromGroupID)
	}
	if m.PingID == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(*m.PingID)))
		i += copy(dAtA[i:], *m.PingID)
	}
	if m.BaseHeight == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTas(dAtA, i, uint64(*m.BaseHeight))
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n27, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateGroupPongMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateGroupPongMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PingID == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(*m.PingID)))
		i += copy(dAtA[i:], *m.PingID)
	}
	if m.Ts == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.Ts)))
		i += copy(dAtA[i:], m.Ts)
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n28, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReqSharePieceMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSharePieceMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GHash)))
		i += copy(dAtA[i:], m.GHash)
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n29, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResponseSharePieceMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseSharePieceMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GHash == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTas(dAtA, i, uint64(len(m.GHash)))
		i += copy(dAtA[i:], m.GHash)
	}
	if m.SharePiece == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.SharePiece.Size()))
		n30, err := m.SharePiece.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Sign == nil {
		return 0, new(proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTas(dAtA, i, uint64(m.Sign.Size()))
		n31, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintTas(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovTas(uint64(*m.Code))
	}
	if m.Signature != nil {
		l = len(m.Signature)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transaction) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Value != nil {
		n += 1 + sovTas(uint64(*m.Value))
	}
	if m.Nonce != nil {
		n += 1 + sovTas(uint64(*m.Nonce))
	}
	if m.Target != nil {
		l = len(m.Target)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.GasLimit != nil {
		n += 1 + sovTas(uint64(*m.GasLimit))
	}
	if m.GasPrice != nil {
		n += 1 + sovTas(uint64(*m.GasPrice))
	}
	if m.Hash != nil {
		l = len(m.Hash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.ExtraData != nil {
		l = len(m.ExtraData)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.ExtraDataType != nil {
		n += 1 + sovTas(uint64(*m.ExtraDataType))
	}
	if m.Type != nil {
		n += 1 + sovTas(uint64(*m.Type))
	}
	if m.Sign != nil {
		l = len(m.Sign)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.TargetAccount != nil {
		l = len(*m.TargetAccount)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.SourceAccount != nil {
		l = len(*m.SourceAccount)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionRequestMessage) Size() (n int) {
	var l int
	_ = l
	if len(m.TransactionHashes) > 0 {
		for _, b := range m.TransactionHashes {
			l = len(b)
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.CurrentBlockHash != nil {
		l = len(m.CurrentBlockHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrieNodes) Size() (n int) {
	var l int
	_ = l
	if len(m.TrieNodes) > 0 {
		for _, e := range m.TrieNodes {
			l = e.Size()
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionSlice) Size() (n int) {
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChainPieceInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Pieces) > 0 {
		for _, b := range m.Pieces {
			l = len(b)
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockHeader) Size() (n int) {
	var l int
	_ = l
	if m.Hash != nil {
		l = len(m.Hash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Height != nil {
		n += 1 + sovTas(uint64(*m.Height))
	}
	if m.PreHash != nil {
		l = len(m.PreHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.PreTime != nil {
		l = len(m.PreTime)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.ProveValue != nil {
		l = len(m.ProveValue)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.TotalQN != nil {
		n += 1 + sovTas(uint64(*m.TotalQN))
	}
	if m.CurTime != nil {
		l = len(m.CurTime)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Castor != nil {
		l = len(m.Castor)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.GroupId != nil {
		l = len(m.GroupId)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Signature != nil {
		l = len(m.Signature)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Nonce != nil {
		n += 1 + sovTas(uint64(*m.Nonce))
	}
	if m.Transactions != nil {
		l = m.Transactions.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.TxTree != nil {
		l = len(m.TxTree)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.ReceiptTree != nil {
		l = len(m.ReceiptTree)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.StateTree != nil {
		l = len(m.StateTree)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.ExtraData != nil {
		l = len(m.ExtraData)
		n += 2 + l + sovTas(uint64(l))
	}
	if m.Random != nil {
		l = len(m.Random)
		n += 2 + l + sovTas(uint64(l))
	}
	if m.ProveRoot != nil {
		l = len(m.ProveRoot)
		n += 2 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockBody) Size() (n int) {
	var l int
	_ = l
	if m.BlockHash != nil {
		l = len(m.BlockHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Block) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockSlice) Size() (n int) {
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Member) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.PubKey != nil {
		l = len(m.PubKey)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupHeader) Size() (n int) {
	var l int
	_ = l
	if m.Hash != nil {
		l = len(m.Hash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Parent != nil {
		l = len(m.Parent)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.PreGroup != nil {
		l = len(m.PreGroup)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Authority != nil {
		n += 1 + sovTas(uint64(*m.Authority))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.BeginTime != nil {
		l = len(m.BeginTime)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.MemberRoot != nil {
		l = len(m.MemberRoot)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.CreateHeight != nil {
		n += 1 + sovTas(uint64(*m.CreateHeight))
	}
	if m.ReadyHeight != nil {
		n += 1 + sovTas(uint64(*m.ReadyHeight))
	}
	if m.WorkHeight != nil {
		n += 1 + sovTas(uint64(*m.WorkHeight))
	}
	if m.DismissHeight != nil {
		n += 1 + sovTas(uint64(*m.DismissHeight))
	}
	if m.Extends != nil {
		l = len(*m.Extends)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Group) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.PubKey != nil {
		l = len(m.PubKey)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Signature != nil {
		l = len(m.Signature)
		n += 1 + l + sovTas(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, b := range m.Members {
			l = len(b)
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.GroupHeight != nil {
		n += 1 + sovTas(uint64(*m.GroupHeight))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupSlice) Size() (n int) {
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupIdSlice) Size() (n int) {
	var l int
	_ = l
	if len(m.GroupIds) > 0 {
		for _, b := range m.GroupIds {
			l = len(b)
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupRequestInfo) Size() (n int) {
	var l int
	_ = l
	if m.CurrentTopGroupId != nil {
		l = len(m.CurrentTopGroupId)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.ExistGroupIds != nil {
		l = m.ExistGroupIds.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Hashes) Size() (n int) {
	var l int
	_ = l
	if len(m.Hashes) > 0 {
		for _, b := range m.Hashes {
			l = len(b)
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TotalQnInfo) Size() (n int) {
	var l int
	_ = l
	if m.TotalQn != nil {
		n += 1 + sovTas(uint64(*m.TotalQn))
	}
	if m.Height != nil {
		n += 1 + sovTas(uint64(*m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.Height != nil {
		n += 1 + sovTas(uint64(*m.Height))
	}
	if m.Transactions != nil {
		l = m.Transactions.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if len(m.Addresses) > 0 {
		for _, b := range m.Addresses {
			l = len(b)
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.BlockHash != nil {
		l = len(m.BlockHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateInfo) Size() (n int) {
	var l int
	_ = l
	if m.Height != nil {
		n += 1 + sovTas(uint64(*m.Height))
	}
	if len(m.TrieNodes) > 0 {
		for _, e := range m.TrieNodes {
			l = e.Size()
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.BlockHash != nil {
		l = len(m.BlockHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.ProBlockStateRoot != nil {
		l = len(m.ProBlockStateRoot)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrieNode) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignData) Size() (n int) {
	var l int
	_ = l
	if m.DataHash != nil {
		l = len(m.DataHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.DataSign != nil {
		l = len(m.DataSign)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.SignMember != nil {
		l = len(m.SignMember)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Version != nil {
		n += 1 + sovTas(uint64(*m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusGroupInitSummary) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Signature != nil {
		l = len(m.Signature)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PubKeyInfo) Size() (n int) {
	var l int
	_ = l
	if m.ID != nil {
		l = len(m.ID)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.PublicKey != nil {
		l = len(m.PublicKey)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusGroupInitInfo) Size() (n int) {
	var l int
	_ = l
	if m.GI != nil {
		l = m.GI.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if len(m.Mems) > 0 {
		for _, b := range m.Mems {
			l = len(b)
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusGroupRawMessage) Size() (n int) {
	var l int
	_ = l
	if m.GInfo != nil {
		l = m.GInfo.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SharePiece) Size() (n int) {
	var l int
	_ = l
	if m.Seckey != nil {
		l = len(m.Seckey)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Pubkey != nil {
		l = len(m.Pubkey)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusSharePieceMessage) Size() (n int) {
	var l int
	_ = l
	if m.GHash != nil {
		l = len(m.GHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Dest != nil {
		l = len(m.Dest)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.SharePiece != nil {
		l = m.SharePiece.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.MemCnt != nil {
		n += 1 + sovTas(uint64(*m.MemCnt))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusSignPubKeyMessage) Size() (n int) {
	var l int
	_ = l
	if m.GHash != nil {
		l = len(m.GHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.GroupID != nil {
		l = len(m.GroupID)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.SignPK != nil {
		l = len(m.SignPK)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.MemCnt != nil {
		n += 1 + sovTas(uint64(*m.MemCnt))
	}
	if m.SignData != nil {
		l = m.SignData.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusSignPubkeyReqMessage) Size() (n int) {
	var l int
	_ = l
	if m.GroupID != nil {
		l = len(m.GroupID)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.SignData != nil {
		l = m.SignData.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StaticGroupSummary) Size() (n int) {
	var l int
	_ = l
	if m.GroupID != nil {
		l = len(m.GroupID)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.GroupPK != nil {
		l = len(m.GroupPK)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.GHash != nil {
		l = len(m.GHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusGroupInitedMessage) Size() (n int) {
	var l int
	_ = l
	if m.GHash != nil {
		l = len(m.GHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.GroupID != nil {
		l = len(m.GroupID)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.GroupPK != nil {
		l = len(m.GroupPK)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.CreateHeight != nil {
		n += 1 + sovTas(uint64(*m.CreateHeight))
	}
	if m.ParentSign != nil {
		l = len(m.ParentSign)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.MemMask != nil {
		l = len(m.MemMask)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.MemCnt != nil {
		n += 1 + sovTas(uint64(*m.MemCnt))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusCurrentMessage) Size() (n int) {
	var l int
	_ = l
	if m.GroupID != nil {
		l = len(m.GroupID)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.PreHash != nil {
		l = len(m.PreHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.PreTime != nil {
		l = len(m.PreTime)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.BlockHeight != nil {
		n += 1 + sovTas(uint64(*m.BlockHeight))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusCastMessage) Size() (n int) {
	var l int
	_ = l
	if m.Bh != nil {
		l = m.Bh.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.GroupID != nil {
		l = len(m.GroupID)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if len(m.ProveHash) > 0 {
		for _, b := range m.ProveHash {
			l = len(b)
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusVerifyMessage) Size() (n int) {
	var l int
	_ = l
	if m.BlockHash != nil {
		l = len(m.BlockHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.RandomSign != nil {
		l = len(m.RandomSign)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusBlockMessage) Size() (n int) {
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusCreateGroupRawMessage) Size() (n int) {
	var l int
	_ = l
	if m.GInfo != nil {
		l = m.GInfo.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusCreateGroupSignMessage) Size() (n int) {
	var l int
	_ = l
	if m.GHash != nil {
		l = len(m.GHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Bonus) Size() (n int) {
	var l int
	_ = l
	if m.TxHash != nil {
		l = len(m.TxHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if len(m.TargetIds) > 0 {
		for _, e := range m.TargetIds {
			n += 1 + sovTas(uint64(e))
		}
	}
	if m.BlockHash != nil {
		l = len(m.BlockHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.GroupId != nil {
		l = len(m.GroupId)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Sign != nil {
		l = len(m.Sign)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.TotalValue != nil {
		n += 1 + sovTas(uint64(*m.TotalValue))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CastRewardTransSignReqMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Reward != nil {
		l = m.Reward.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if len(m.SignedPieces) > 0 {
		for _, b := range m.SignedPieces {
			l = len(b)
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CastRewardTransSignMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.ReqHash != nil {
		l = len(m.ReqHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.BlockHash != nil {
		l = len(m.BlockHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopBlockInfo) Size() (n int) {
	var l int
	_ = l
	if m.Hash != nil {
		l = len(m.Hash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.TotalQn != nil {
		n += 1 + sovTas(uint64(*m.TotalQn))
	}
	if m.Height != nil {
		n += 1 + sovTas(uint64(*m.Height))
	}
	if m.PreHash != nil {
		l = len(m.PreHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.ShrinkPV != nil {
		n += 1 + sovTas(uint64(*m.ShrinkPV))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChainPieceBlockMsg) Size() (n int) {
	var l int
	_ = l
	if m.TopHeader != nil {
		l = m.TopHeader.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovTas(uint64(l))
		}
	}
	if m.FindAncestor != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateGroupPingMessage) Size() (n int) {
	var l int
	_ = l
	if m.FromGroupID != nil {
		l = len(m.FromGroupID)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.PingID != nil {
		l = len(*m.PingID)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.BaseHeight != nil {
		n += 1 + sovTas(uint64(*m.BaseHeight))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateGroupPongMessage) Size() (n int) {
	var l int
	_ = l
	if m.PingID != nil {
		l = len(*m.PingID)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Ts != nil {
		l = len(m.Ts)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReqSharePieceMessage) Size() (n int) {
	var l int
	_ = l
	if m.GHash != nil {
		l = len(m.GHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseSharePieceMessage) Size() (n int) {
	var l int
	_ = l
	if m.GHash != nil {
		l = len(m.GHash)
		n += 1 + l + sovTas(uint64(l))
	}
	if m.SharePiece != nil {
		l = m.SharePiece.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovTas(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTas(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTas(x uint64) (n int) {
	return sovTas(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Message) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nonce = &v
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GasLimit = &v
			hasFields[0] |= uint64(0x00000002)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GasPrice = &v
			hasFields[0] |= uint64(0x00000004)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraData = append(m.ExtraData[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtraData == nil {
				m.ExtraData = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraDataType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExtraDataType = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000010)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign[:0], dAtA[iNdEx:postIndex]...)
			if m.Sign == nil {
				m.Sign = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TargetAccount = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SourceAccount = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionRequestMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionRequestMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionRequestMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionHashes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionHashes = append(m.TransactionHashes, make([]byte, postIndex-iNdEx))
			copy(m.TransactionHashes[len(m.TransactionHashes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentBlockHash = append(m.CurrentBlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.CurrentBlockHash == nil {
				m.CurrentBlockHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrieNodes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrieNodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrieNodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrieNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrieNodes = append(m.TrieNodes, &TrieNode{})
			if err := m.TrieNodes[len(m.TrieNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainPieceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainPieceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainPieceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pieces", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pieces = append(m.Pieces, make([]byte, postIndex-iNdEx))
			copy(m.Pieces[len(m.Pieces)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Height = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreHash = append(m.PreHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PreHash == nil {
				m.PreHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreTime", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreTime = append(m.PreTime[:0], dAtA[iNdEx:postIndex]...)
			if m.PreTime == nil {
				m.PreTime = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProveValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProveValue = append(m.ProveValue[:0], dAtA[iNdEx:postIndex]...)
			if m.ProveValue == nil {
				m.ProveValue = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalQN", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalQN = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurTime", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurTime = append(m.CurTime[:0], dAtA[iNdEx:postIndex]...)
			if m.CurTime == nil {
				m.CurTime = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Castor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Castor = append(m.Castor[:0], dAtA[iNdEx:postIndex]...)
			if m.Castor == nil {
				m.Castor = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = append(m.GroupId[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupId == nil {
				m.GroupId = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nonce = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transactions == nil {
				m.Transactions = &Hashes{}
			}
			if err := m.Transactions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxTree", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxTree = append(m.TxTree[:0], dAtA[iNdEx:postIndex]...)
			if m.TxTree == nil {
				m.TxTree = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiptTree", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReceiptTree = append(m.ReceiptTree[:0], dAtA[iNdEx:postIndex]...)
			if m.ReceiptTree == nil {
				m.ReceiptTree = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateTree", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateTree = append(m.StateTree[:0], dAtA[iNdEx:postIndex]...)
			if m.StateTree == nil {
				m.StateTree = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraData = append(m.ExtraData[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtraData == nil {
				m.ExtraData = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Random", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Random = append(m.Random[:0], dAtA[iNdEx:postIndex]...)
			if m.Random == nil {
				m.Random = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProveRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProveRoot = append(m.ProveRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.ProveRoot == nil {
				m.ProveRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockBody) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = append(m.BlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockHash == nil {
				m.BlockHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &BlockHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupHeader) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = append(m.Parent[:0], dAtA[iNdEx:postIndex]...)
			if m.Parent == nil {
				m.Parent = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreGroup", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreGroup = append(m.PreGroup[:0], dAtA[iNdEx:postIndex]...)
			if m.PreGroup == nil {
				m.PreGroup = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Authority = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginTime", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeginTime = append(m.BeginTime[:0], dAtA[iNdEx:postIndex]...)
			if m.BeginTime == nil {
				m.BeginTime = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemberRoot = append(m.MemberRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.MemberRoot == nil {
				m.MemberRoot = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateHeight = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadyHeight = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WorkHeight = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DismissHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DismissHeight = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extends", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Extends = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &GroupHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, make([]byte, postIndex-iNdEx))
			copy(m.Members[len(m.Members)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GroupHeight = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupIdSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupIdSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupIdSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupIds = append(m.GroupIds, make([]byte, postIndex-iNdEx))
			copy(m.GroupIds[len(m.GroupIds)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupRequestInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupRequestInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupRequestInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTopGroupId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentTopGroupId = append(m.CurrentTopGroupId[:0], dAtA[iNdEx:postIndex]...)
			if m.CurrentTopGroupId == nil {
				m.CurrentTopGroupId = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistGroupIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistGroupIds == nil {
				m.ExistGroupIds = &GroupIdSlice{}
			}
			if err := m.ExistGroupIds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hashes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hashes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hashes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hashes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hashes = append(m.Hashes, make([]byte, postIndex-iNdEx))
			copy(m.Hashes[len(m.Hashes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalQnInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalQnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalQnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalQn", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalQn = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Height = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateInfoReq) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Height = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transactions == nil {
				m.Transactions = &TransactionSlice{}
			}
			if err := m.Transactions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, make([]byte, postIndex-iNdEx))
			copy(m.Addresses[len(m.Addresses)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = append(m.BlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockHash == nil {
				m.BlockHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Height = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrieNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrieNodes = append(m.TrieNodes, &TrieNode{})
			if err := m.TrieNodes[len(m.TrieNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = append(m.BlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockHash == nil {
				m.BlockHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProBlockStateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProBlockStateRoot = append(m.ProBlockStateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.ProBlockStateRoot == nil {
				m.ProBlockStateRoot = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrieNode) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrieNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrieNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignData) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHash = append(m.DataHash[:0], dAtA[iNdEx:postIndex]...)
			if m.DataHash == nil {
				m.DataHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSign = append(m.DataSign[:0], dAtA[iNdEx:postIndex]...)
			if m.DataSign == nil {
				m.DataSign = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignMember", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignMember = append(m.SignMember[:0], dAtA[iNdEx:postIndex]...)
			if m.SignMember == nil {
				m.SignMember = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusGroupInitSummary) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusGroupInitSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusGroupInitSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &GroupHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PubKeyInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PubKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PubKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusGroupInitInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusGroupInitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusGroupInitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GI", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GI == nil {
				m.GI = &ConsensusGroupInitSummary{}
			}
			if err := m.GI.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mems", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mems = append(m.Mems, make([]byte, postIndex-iNdEx))
			copy(m.Mems[len(m.Mems)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusGroupRawMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusGroupRawMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusGroupRawMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GInfo == nil {
				m.GInfo = &ConsensusGroupInitInfo{}
			}
			if err := m.GInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SharePiece) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SharePiece: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SharePiece: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seckey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seckey = append(m.Seckey[:0], dAtA[iNdEx:postIndex]...)
			if m.Seckey == nil {
				m.Seckey = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pubkey = append(m.Pubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.Pubkey == nil {
				m.Pubkey = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusSharePieceMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusSharePieceMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusSharePieceMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GHash = append(m.GHash[:0], dAtA[iNdEx:postIndex]...)
			if m.GHash == nil {
				m.GHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dest = append(m.Dest[:0], dAtA[iNdEx:postIndex]...)
			if m.Dest == nil {
				m.Dest = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePiece", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SharePiece == nil {
				m.SharePiece = &SharePiece{}
			}
			if err := m.SharePiece.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCnt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemCnt = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusSignPubKeyMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusSignPubKeyMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusSignPubKeyMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GHash = append(m.GHash[:0], dAtA[iNdEx:postIndex]...)
			if m.GHash == nil {
				m.GHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = append(m.GroupID[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupID == nil {
				m.GroupID = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPK", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignPK = append(m.SignPK[:0], dAtA[iNdEx:postIndex]...)
			if m.SignPK == nil {
				m.SignPK = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCnt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemCnt = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignData == nil {
				m.SignData = &SignData{}
			}
			if err := m.SignData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusSignPubkeyReqMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusSignPubkeyReqMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusSignPubkeyReqMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = append(m.GroupID[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupID == nil {
				m.GroupID = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignData == nil {
				m.SignData = &SignData{}
			}
			if err := m.SignData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticGroupSummary) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticGroupSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticGroupSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = append(m.GroupID[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupID == nil {
				m.GroupID = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPK", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupPK = append(m.GroupPK[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupPK == nil {
				m.GroupPK = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GHash = append(m.GHash[:0], dAtA[iNdEx:postIndex]...)
			if m.GHash == nil {
				m.GHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusGroupInitedMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusGroupInitedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusGroupInitedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GHash = append(m.GHash[:0], dAtA[iNdEx:postIndex]...)
			if m.GHash == nil {
				m.GHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = append(m.GroupID[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupID == nil {
				m.GroupID = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPK", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupPK = append(m.GroupPK[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupPK == nil {
				m.GroupPK = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateHeight = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentSign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentSign = append(m.ParentSign[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentSign == nil {
				m.ParentSign = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemMask", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemMask = append(m.MemMask[:0], dAtA[iNdEx:postIndex]...)
			if m.MemMask == nil {
				m.MemMask = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCnt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemCnt = &v
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000080)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusCurrentMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusCurrentMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusCurrentMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = append(m.GroupID[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupID == nil {
				m.GroupID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreHash = append(m.PreHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PreHash == nil {
				m.PreHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreTime", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreTime = append(m.PreTime[:0], dAtA[iNdEx:postIndex]...)
			if m.PreTime == nil {
				m.PreTime = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockHeight = &v
			hasFields[0] |= uint64(0x00000004)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusCastMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusCastMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusCastMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bh == nil {
				m.Bh = &BlockHeader{}
			}
			if err := m.Bh.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = append(m.GroupID[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupID == nil {
				m.GroupID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProveHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProveHash = append(m.ProveHash, make([]byte, postIndex-iNdEx))
			copy(m.ProveHash[len(m.ProveHash)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusVerifyMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusVerifyMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusVerifyMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = append(m.BlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockHash == nil {
				m.BlockHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RandomSign = append(m.RandomSign[:0], dAtA[iNdEx:postIndex]...)
			if m.RandomSign == nil {
				m.RandomSign = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusBlockMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusBlockMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusBlockMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusCreateGroupRawMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusCreateGroupRawMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusCreateGroupRawMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GInfo == nil {
				m.GInfo = &ConsensusGroupInitInfo{}
			}
			if err := m.GInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusCreateGroupSignMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusCreateGroupSignMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusCreateGroupSignMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GHash = append(m.GHash[:0], dAtA[iNdEx:postIndex]...)
			if m.GHash == nil {
				m.GHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bonus) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bonus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bonus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTas
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetIds = append(m.TargetIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTas
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTas
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTas
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetIds = append(m.TargetIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIds", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = append(m.BlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockHash == nil {
				m.BlockHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = append(m.GroupId[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupId == nil {
				m.GroupId = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign[:0], dAtA[iNdEx:postIndex]...)
			if m.Sign == nil {
				m.Sign = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalValue = &v
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CastRewardTransSignReqMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CastRewardTransSignReqMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CastRewardTransSignReqMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reward == nil {
				m.Reward = &Bonus{}
			}
			if err := m.Reward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedPieces", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedPieces = append(m.SignedPieces, make([]byte, postIndex-iNdEx))
			copy(m.SignedPieces[len(m.SignedPieces)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CastRewardTransSignMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CastRewardTransSignMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CastRewardTransSignMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqHash = append(m.ReqHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ReqHash == nil {
				m.ReqHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = append(m.BlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockHash == nil {
				m.BlockHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopBlockInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopBlockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopBlockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalQn", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TotalQn = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Height = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreHash = append(m.PreHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PreHash == nil {
				m.PreHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShrinkPV", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShrinkPV = &v
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainPieceBlockMsg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainPieceBlockMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainPieceBlockMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopHeader == nil {
				m.TopHeader = &BlockHeader{}
			}
			if err := m.TopHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindAncestor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FindAncestor = &b
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateGroupPingMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateGroupPingMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateGroupPingMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromGroupID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromGroupID = append(m.FromGroupID[:0], dAtA[iNdEx:postIndex]...)
			if m.FromGroupID == nil {
				m.FromGroupID = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PingID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BaseHeight = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateGroupPongMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateGroupPongMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateGroupPongMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PingID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ts = append(m.Ts[:0], dAtA[iNdEx:postIndex]...)
			if m.Ts == nil {
				m.Ts = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSharePieceMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSharePieceMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSharePieceMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GHash = append(m.GHash[:0], dAtA[iNdEx:postIndex]...)
			if m.GHash == nil {
				m.GHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseSharePieceMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTas
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseSharePieceMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseSharePieceMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GHash = append(m.GHash[:0], dAtA[iNdEx:postIndex]...)
			if m.GHash == nil {
				m.GHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePiece", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SharePiece == nil {
				m.SharePiece = &SharePiece{}
			}
			if err := m.SharePiece.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTas
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTas
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignData{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipTas(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTas
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTas(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTas
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTas
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTas
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTas
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTas
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTas(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTas = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTas   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("tas.proto", fileDescriptorTas) }

var fileDescriptorTas = []byte{
	// 2058 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0xa7, 0x7b, 0x3e, 0xec, 0x79, 0x33, 0x09, 0x76, 0x2b, 0x98, 0x4e, 0x42, 0x66, 0x47, 0x05,
	0x07, 0xb3, 0x8a, 0x8c, 0xb5, 0x07, 0x10, 0xab, 0x84, 0x55, 0x6c, 0x27, 0x5e, 0x2b, 0x38, 0x0c,
	0xe5, 0x91, 0x39, 0x81, 0xd4, 0x99, 0xae, 0x1d, 0x37, 0xf6, 0x74, 0x8f, 0xbb, 0x7b, 0xd8, 0xf8,
	0xc4, 0x01, 0xa1, 0x95, 0x10, 0xe2, 0x90, 0x13, 0x57, 0x84, 0x84, 0xf8, 0x38, 0x70, 0xe2, 0xc2,
	0x8d, 0x1b, 0x27, 0xc4, 0x9f, 0x80, 0xc2, 0x09, 0xf1, 0x4f, 0xa0, 0xf7, 0xea, 0xa3, 0xab, 0x66,
	0xc6, 0x66, 0xc6, 0x82, 0x53, 0xf7, 0x7b, 0xf5, 0xf5, 0xab, 0x57, 0xbf, 0xf7, 0x51, 0x05, 0xad,
	0x32, 0x2a, 0x76, 0x26, 0x79, 0x56, 0x66, 0xc1, 0x26, 0xfe, 0x8e, 0x93, 0x38, 0xbe, 0x10, 0x9f,
	0x46, 0xb9, 0xd8, 0x99, 0xbc, 0x66, 0xdf, 0x81, 0xb5, 0x63, 0x51, 0x14, 0xd1, 0x48, 0x04, 0x01,
	0xd4, 0xf7, 0xb3, 0x58, 0x84, 0x5e, 0xcf, 0xdf, 0xbe, 0xc3, 0xe9, 0x3f, 0xf8, 0x12, 0xb4, 0x4e,
	0x92, 0x51, 0x1a, 0x95, 0xd3, 0x5c, 0x84, 0x7e, 0xcf, 0xdb, 0xee, 0xf0, 0x4a, 0x81, 0x23, 0xf6,
	0xb2, 0xf8, 0x2a, 0xac, 0x51, 0x03, 0xfd, 0xb3, 0x7f, 0xf9, 0xd0, 0x1e, 0xe4, 0x51, 0x5a, 0x44,
	0xc3, 0x32, 0xc9, 0x52, 0xec, 0x73, 0x10, 0x95, 0x51, 0xe8, 0xc9, 0x3e, 0xf8, 0x1f, 0xdc, 0x83,
	0xc6, 0x69, 0x74, 0x31, 0x95, 0x33, 0xd6, 0xb9, 0x14, 0x50, 0xfb, 0x2a, 0x4b, 0x87, 0x22, 0xac,
	0xf5, 0x7c, 0xd4, 0x92, 0x10, 0x6c, 0x41, 0x73, 0x10, 0xe5, 0x23, 0x51, 0x86, 0x75, 0x9a, 0x41,
	0x49, 0xc1, 0x03, 0x58, 0x3f, 0x8c, 0x8a, 0x6f, 0x27, 0xe3, 0xa4, 0x0c, 0x1b, 0x34, 0xc0, 0xc8,
	0xaa, 0xad, 0x9f, 0x27, 0x43, 0x11, 0x36, 0x4d, 0x1b, 0xc9, 0x88, 0xe7, 0xe3, 0xa8, 0x38, 0x0b,
	0xd7, 0x7a, 0x3e, 0xe2, 0xc1, 0x7f, 0xdc, 0xe5, 0xf3, 0x37, 0x65, 0x1e, 0x11, 0xd0, 0x75, 0xb9,
	0x4b, 0xa3, 0x08, 0xbe, 0x02, 0x77, 0x8c, 0x30, 0xb8, 0x9a, 0x88, 0xb0, 0xd5, 0xf3, 0xb6, 0x1b,
	0xdc, 0x55, 0xe2, 0xbc, 0xd4, 0x08, 0x3d, 0x7f, 0xbb, 0xc1, 0xeb, 0x5a, 0x87, 0xc6, 0x0a, 0xdb,
	0x72, 0xef, 0xf8, 0x8f, 0xb3, 0xc9, 0x1d, 0x3c, 0x1b, 0x0e, 0xb3, 0x69, 0x5a, 0x86, 0x9d, 0x9e,
	0xb7, 0xdd, 0xe2, 0xae, 0x12, 0x7b, 0x9d, 0x64, 0xd3, 0x7c, 0x28, 0x74, 0xaf, 0x3b, 0xb2, 0x97,
	0xa3, 0x64, 0x53, 0xb8, 0x6f, 0x99, 0x9a, 0x8b, 0xcb, 0xa9, 0x28, 0x4a, 0x7d, 0x9c, 0x8f, 0x61,
	0xd3, 0x6a, 0xc4, 0x7d, 0x8a, 0x22, 0xf4, 0x7a, 0xb5, 0xed, 0x0e, 0x9f, 0x6f, 0x08, 0xde, 0x87,
	0x8d, 0xfd, 0x69, 0x9e, 0x8b, 0xb4, 0xdc, 0xbb, 0xc8, 0x86, 0xe7, 0x64, 0x22, 0x9f, 0x4c, 0x34,
	0xa7, 0x67, 0x2f, 0xa0, 0x35, 0xc8, 0x13, 0xf1, 0x2a, 0x8b, 0x45, 0x11, 0x7c, 0xd3, 0x12, 0x68,
	0xfa, 0xf6, 0x07, 0x0f, 0x77, 0xe6, 0x78, 0xb6, 0xa3, 0xfb, 0xf0, 0xaa, 0x37, 0x3b, 0x85, 0x0d,
	0x0b, 0xc8, 0xc9, 0x05, 0x1e, 0xcf, 0x1e, 0x74, 0xca, 0x4a, 0xa7, 0x67, 0xec, 0x2e, 0x9c, 0xb1,
	0xda, 0xb9, 0x33, 0x86, 0x6d, 0xc3, 0xdd, 0xfd, 0xb3, 0x28, 0x49, 0xfb, 0x89, 0x18, 0x8a, 0xa3,
	0xf4, 0x93, 0x0c, 0x49, 0x44, 0x82, 0x36, 0x80, 0x92, 0xd8, 0xdb, 0x3a, 0xb4, 0xe5, 0xbe, 0x44,
	0x14, 0x8b, 0xdc, 0x90, 0x43, 0x91, 0x95, 0xc8, 0xb1, 0x05, 0xcd, 0x8f, 0x45, 0x32, 0x3a, 0x2b,
	0x15, 0x5b, 0x95, 0x14, 0x84, 0xb0, 0xd6, 0xcf, 0x05, 0x75, 0x97, 0xfc, 0xd7, 0xa2, 0x6a, 0x19,
	0x24, 0x63, 0xa1, 0x38, 0xab, 0xc5, 0xa0, 0x0b, 0xd0, 0xcf, 0xb3, 0x1f, 0x09, 0xc9, 0xfe, 0x06,
	0x35, 0x5a, 0x1a, 0x1c, 0x39, 0xc8, 0xca, 0xe8, 0xe2, 0xbb, 0xaf, 0xc2, 0x26, 0x2d, 0xa6, 0x45,
	0x6c, 0xd9, 0x9f, 0xe6, 0x34, 0xe7, 0x9a, 0x9c, 0x53, 0x89, 0x88, 0x6f, 0x3f, 0x2a, 0xca, 0x2c,
	0x57, 0xcc, 0x55, 0x12, 0x8e, 0x38, 0xcc, 0xb3, 0xe9, 0xe4, 0x28, 0x26, 0xc2, 0x76, 0xb8, 0x16,
	0x5d, 0xa7, 0x86, 0x59, 0xa7, 0x36, 0x6e, 0xd8, 0x96, 0xce, 0x29, 0xdd, 0xf0, 0xe9, 0xcc, 0xb9,
	0x20, 0x6b, 0xdb, 0x1f, 0xdc, 0x5f, 0x70, 0x2e, 0x92, 0x50, 0xee, 0x91, 0x90, 0x17, 0xbf, 0x19,
	0xe4, 0x42, 0x10, 0x91, 0xd1, 0x8b, 0x49, 0x0a, 0x7a, 0xd0, 0xe6, 0x62, 0x28, 0x92, 0x49, 0x49,
	0x8d, 0x77, 0xa9, 0xd1, 0x56, 0x11, 0xd8, 0x32, 0x2a, 0x05, 0xb5, 0x7f, 0x5e, 0x81, 0xd5, 0x0a,
	0xd7, 0x73, 0x37, 0x66, 0x3d, 0x77, 0x0b, 0x9a, 0x3c, 0x4a, 0xe3, 0x6c, 0x1c, 0x6e, 0xca, 0x55,
	0xa5, 0x84, 0xa3, 0xc8, 0xe8, 0x3c, 0xcb, 0xca, 0x30, 0x90, 0xa3, 0x8c, 0x82, 0x8d, 0xa1, 0x45,
	0x9c, 0xc0, 0x70, 0x86, 0x5d, 0x2b, 0x87, 0xf0, 0xc8, 0x21, 0x2a, 0xc5, 0x1c, 0x5b, 0xfd, 0x5b,
	0xb0, 0xf5, 0x27, 0x1e, 0x34, 0x68, 0xc6, 0xe0, 0xeb, 0xc8, 0x34, 0xe4, 0x21, 0x2d, 0xb4, 0x78,
	0x1e, 0x8b, 0xad, 0x5c, 0xf5, 0xfe, 0x9f, 0xa0, 0xf8, 0x16, 0x00, 0x4d, 0x2d, 0xbd, 0x70, 0x17,
	0x9a, 0x24, 0x69, 0xff, 0x0b, 0xaf, 0x43, 0xc2, 0x55, 0x3f, 0xb6, 0x0b, 0xcd, 0x63, 0x31, 0x7e,
	0x2d, 0xf2, 0xe0, 0x2e, 0xf8, 0x47, 0xb1, 0x32, 0x95, 0x7f, 0x14, 0x93, 0xef, 0x4d, 0x5f, 0xbf,
	0x14, 0x57, 0x2a, 0x9e, 0x28, 0x89, 0xfd, 0xdb, 0x87, 0x36, 0x31, 0xf2, 0x66, 0xdf, 0xeb, 0x47,
	0x18, 0x7c, 0x54, 0xee, 0x51, 0x12, 0x06, 0xf8, 0x7e, 0x2e, 0x68, 0x34, 0x65, 0x8b, 0x0e, 0x37,
	0x32, 0x9e, 0xd8, 0xb3, 0x69, 0x79, 0x96, 0xe5, 0x49, 0x79, 0x45, 0xfe, 0x57, 0xe7, 0x95, 0x02,
	0x57, 0x79, 0x15, 0x8d, 0xa5, 0xef, 0xb5, 0x38, 0xfd, 0xd3, 0x19, 0x8b, 0x51, 0x92, 0x92, 0x77,
	0x35, 0x25, 0x1d, 0x8c, 0x02, 0x7d, 0x56, 0xee, 0x8c, 0xd8, 0x22, 0x9d, 0xcf, 0xd2, 0x04, 0x0c,
	0x3a, 0xfb, 0xb9, 0x88, 0x4a, 0xa1, 0xa2, 0xc4, 0x3a, 0x2d, 0xe9, 0xe8, 0x24, 0xcd, 0xa3, 0xf8,
	0x4a, 0x75, 0x69, 0x51, 0x17, 0x5b, 0x85, 0xab, 0x7c, 0x2f, 0xcb, 0xcf, 0x55, 0x07, 0xa0, 0x0e,
	0x96, 0x06, 0x13, 0xc2, 0x41, 0x52, 0x8c, 0x93, 0xa2, 0x50, 0x5d, 0xa4, 0x77, 0xba, 0x4a, 0xf4,
	0xf9, 0xe7, 0x6f, 0x4a, 0x91, 0xc6, 0x85, 0x4a, 0x2b, 0x5a, 0x64, 0x7f, 0xf1, 0xa0, 0x21, 0xed,
	0xb3, 0x0c, 0xcb, 0xac, 0x73, 0x31, 0x2c, 0x93, 0xe7, 0x2a, 0xcf, 0xc1, 0x3d, 0xd7, 0x9a, 0x3a,
	0x1b, 0x92, 0xdc, 0xe8, 0x52, 0x9f, 0x8d, 0x2e, 0x21, 0xd6, 0x1b, 0x68, 0xbb, 0x22, 0x6c, 0x50,
	0x28, 0xd6, 0x22, 0xda, 0x48, 0x2d, 0x4b, 0xfb, 0x93, 0xf1, 0xcf, 0x56, 0xb1, 0xa7, 0xd0, 0x92,
	0x21, 0x0c, 0x43, 0xfa, 0x2e, 0x34, 0x49, 0xb8, 0x89, 0xa2, 0xd4, 0x81, 0xab, 0x7e, 0x48, 0x71,
	0xfa, 0x33, 0x14, 0x5f, 0x71, 0xfc, 0xfb, 0xd0, 0x51, 0x11, 0x54, 0xce, 0x80, 0x55, 0x86, 0x94,
	0x75, 0x5a, 0x31, 0x32, 0xfb, 0xcc, 0x83, 0x0d, 0x39, 0x5a, 0x26, 0x65, 0x82, 0xfc, 0x18, 0x36,
	0x55, 0x2e, 0x1d, 0x64, 0x13, 0x1d, 0x9b, 0xa5, 0xa3, 0xcc, 0x37, 0x04, 0xcf, 0xb1, 0xec, 0x48,
	0x8a, 0xd2, 0xac, 0xe1, 0x53, 0xc8, 0x7d, 0xef, 0x3a, 0x9c, 0x0a, 0x16, 0x77, 0x47, 0xb1, 0x1e,
	0x34, 0x55, 0x8a, 0xdf, 0x82, 0xe6, 0x99, 0x5d, 0x05, 0x28, 0x89, 0x7d, 0x04, 0x6d, 0x99, 0x65,
	0x52, 0x42, 0x69, 0x72, 0x50, 0x4a, 0xd8, 0x4c, 0x0e, 0x4a, 0x9d, 0x4c, 0xe8, 0x57, 0x99, 0x90,
	0xfd, 0xc1, 0x83, 0x0e, 0x85, 0x64, 0x1c, 0xcf, 0xc5, 0xa5, 0xd5, 0xd1, 0xb3, 0x3b, 0x06, 0x87,
	0xd0, 0x19, 0xb8, 0x81, 0x0a, 0x77, 0xf4, 0xe5, 0x9b, 0x03, 0x95, 0xdc, 0x95, 0x33, 0x90, 0x7c,
	0x3c, 0x8e, 0x73, 0x51, 0x14, 0xa2, 0x08, 0x6b, 0xb4, 0x9b, 0x4a, 0xe1, 0xc6, 0xec, 0xfa, 0x4c,
	0xcc, 0x66, 0xbf, 0xf7, 0x54, 0x46, 0xd1, 0x95, 0xc1, 0x42, 0xa8, 0x4e, 0x59, 0xe3, 0xaf, 0x52,
	0xd6, 0xb8, 0xcb, 0xd7, 0x66, 0x53, 0xc6, 0x63, 0xd8, 0xec, 0xe7, 0x99, 0x8c, 0xb5, 0x88, 0x82,
	0xa2, 0x8a, 0x04, 0x39, 0xdf, 0xc0, 0x76, 0x61, 0x5d, 0x4f, 0x1c, 0x6c, 0x40, 0x0d, 0xbd, 0x4d,
	0x12, 0x06, 0x7f, 0x4d, 0x6d, 0x2d, 0x03, 0x2b, 0xfd, 0xb3, 0x1f, 0xc3, 0x3a, 0x7a, 0x1b, 0xe5,
	0xbf, 0x07, 0xb0, 0x8e, 0x5f, 0x2b, 0x77, 0x19, 0x59, 0xb7, 0x51, 0x7d, 0xea, 0x57, 0x6d, 0x54,
	0xa3, 0x76, 0x01, 0xf0, 0x2b, 0x3d, 0x53, 0x6d, 0xc1, 0xd2, 0x04, 0x0f, 0x61, 0xed, 0x54, 0xe4,
	0x45, 0x92, 0xa5, 0xe4, 0xe0, 0x8d, 0x0f, 0xbd, 0x5d, 0xae, 0x35, 0xec, 0x12, 0xee, 0xef, 0x67,
	0x69, 0x21, 0xd2, 0x62, 0x5a, 0x28, 0x77, 0x4d, 0xca, 0x93, 0xe9, 0x78, 0x1c, 0xe5, 0x57, 0xb7,
	0x0e, 0x3e, 0x33, 0xf7, 0x10, 0xdf, 0x09, 0x2a, 0xec, 0x43, 0x00, 0x19, 0x7c, 0xe8, 0x48, 0x31,
	0x50, 0x1d, 0x98, 0x04, 0x74, 0x40, 0xd9, 0x7e, 0xfa, 0xfa, 0x22, 0x19, 0x56, 0x39, 0xa8, 0x52,
	0xb0, 0x1f, 0xc2, 0xd6, 0x3c, 0x5c, 0x9a, 0xe7, 0x09, 0xf8, 0x87, 0x47, 0x0a, 0xe7, 0xe3, 0x05,
	0x38, 0xaf, 0xdd, 0x25, 0xf7, 0x0f, 0x8f, 0xf0, 0x6c, 0x8e, 0xc5, 0x58, 0x72, 0xa7, 0xc3, 0xe9,
	0x9f, 0xfd, 0xdc, 0x83, 0xd0, 0x1d, 0xc5, 0xa3, 0x4f, 0x75, 0xbd, 0xfe, 0x11, 0x34, 0x0e, 0x71,
	0x5d, 0xb5, 0xe2, 0x57, 0x97, 0x5a, 0x91, 0x3c, 0x4e, 0x8e, 0x0b, 0xbe, 0x06, 0xf5, 0x02, 0x4f,
	0xb3, 0x46, 0xe3, 0x17, 0xb1, 0x55, 0x13, 0x83, 0x53, 0x47, 0xf6, 0x04, 0xe0, 0xe4, 0x2c, 0xca,
	0x05, 0x15, 0xc3, 0xe8, 0x09, 0x27, 0x62, 0x78, 0x6e, 0x18, 0xa6, 0x24, 0x15, 0xe7, 0xcf, 0x9d,
	0xfc, 0x7d, 0x2e, 0xae, 0xd8, 0xdf, 0x3c, 0x78, 0x60, 0x00, 0x55, 0xf3, 0xe8, 0xed, 0xdc, 0x83,
	0xc6, 0xa1, 0x45, 0x3c, 0x29, 0x10, 0x63, 0x45, 0x51, 0x1a, 0xc6, 0x8a, 0xa2, 0x0c, 0x9e, 0xda,
	0x30, 0x14, 0xfa, 0x47, 0x8b, 0xd0, 0x9b, 0x4e, 0x7c, 0x06, 0xf7, 0xb1, 0x18, 0xef, 0xa7, 0xd2,
	0x8b, 0x1a, 0x5c, 0x49, 0x68, 0x0e, 0x22, 0x77, 0x63, 0x09, 0x73, 0xe0, 0x1f, 0xfb, 0x93, 0xb3,
	0xa1, 0x64, 0x94, 0x4a, 0x4e, 0xdd, 0xbc, 0x21, 0x53, 0x65, 0x1f, 0xa8, 0x3d, 0x69, 0x91, 0xec,
	0x89, 0x93, 0xbc, 0x54, 0x0e, 0xa4, 0xa4, 0x6b, 0xf1, 0x7e, 0xa3, 0x72, 0xdc, 0x65, 0x30, 0x9b,
	0xce, 0x2c, 0x87, 0x47, 0xb3, 0xb0, 0xcf, 0xc5, 0x15, 0x17, 0x97, 0x1a, 0xb9, 0x85, 0xd1, 0x73,
	0x31, 0xda, 0x6b, 0xfa, 0xab, 0xac, 0xf9, 0x03, 0x08, 0x30, 0x48, 0x25, 0x43, 0x99, 0x51, 0x95,
	0x77, 0x5f, 0xbf, 0x90, 0x6e, 0xe9, 0xbf, 0x74, 0xcc, 0xd4, 0x7f, 0x59, 0x99, 0xb5, 0x66, 0x99,
	0x95, 0xfd, 0xc2, 0x87, 0x87, 0xf3, 0x6c, 0x17, 0xf1, 0x6d, 0x0f, 0xc3, 0x5a, 0xbf, 0xe6, 0xae,
	0x3f, 0x5b, 0xbe, 0xd5, 0x29, 0x0d, 0xb8, 0xe5, 0x1b, 0x5e, 0xdb, 0xa8, 0xf0, 0x34, 0x84, 0xc2,
	0x6b, 0x9b, 0xd1, 0xa8, 0xa2, 0xe6, 0x38, 0x2a, 0xce, 0xe9, 0xb9, 0x41, 0x16, 0x35, 0x28, 0x5a,
	0x87, 0xbd, 0xb6, 0x90, 0x9c, 0xeb, 0xcb, 0x92, 0xf3, 0xcf, 0x1e, 0x7c, 0xd1, 0x18, 0x44, 0x15,
	0x0b, 0x0b, 0xcf, 0xd7, 0x9b, 0xd9, 0xb6, 0xbe, 0xa3, 0x2a, 0x83, 0x2c, 0xb8, 0xa3, 0xd6, 0x4c,
	0x0b, 0xd5, 0xbb, 0x3d, 0x73, 0x25, 0xb6, 0xec, 0x61, 0xab, 0x0c, 0xf8, 0xe6, 0xb2, 0xe0, 0xff,
	0xe8, 0xc1, 0xbd, 0x0a, 0x7c, 0x54, 0xbd, 0x51, 0xec, 0x80, 0xbf, 0x77, 0xb6, 0xe4, 0x6d, 0xc7,
	0xdf, 0x9b, 0x39, 0x60, 0x67, 0xa7, 0x1a, 0x53, 0x6d, 0x49, 0x4c, 0xe6, 0x0e, 0xa8, 0x8a, 0x84,
	0x9a, 0xb9, 0x03, 0x12, 0xff, 0x3e, 0xf3, 0xac, 0xb4, 0x70, 0x2a, 0xf2, 0xe4, 0x13, 0x13, 0x07,
	0x6e, 0xbe, 0x11, 0x76, 0x01, 0xe4, 0x25, 0xd3, 0x4a, 0xac, 0x96, 0x66, 0x65, 0x9c, 0xec, 0x10,
	0xbe, 0x60, 0x80, 0xd0, 0x32, 0x95, 0xed, 0xe4, 0xb5, 0x51, 0x99, 0xef, 0xfa, 0x2b, 0x9a, 0xec,
	0xc6, 0xde, 0x7a, 0xd0, 0xad, 0x0e, 0x81, 0xe8, 0xfd, 0x7f, 0x4b, 0x41, 0xfe, 0xb2, 0x29, 0xe8,
	0x0c, 0xde, 0x5b, 0x84, 0x49, 0xd6, 0x1a, 0x37, 0xb9, 0xfa, 0xca, 0x2b, 0xfd, 0x0e, 0xaf, 0xd9,
	0x59, 0x3a, 0x55, 0x6f, 0x11, 0xd6, 0x8c, 0x4a, 0xc2, 0x83, 0x95, 0x8f, 0x70, 0xb2, 0xd8, 0xae,
	0x6d, 0x37, 0x78, 0xa5, 0xf8, 0x2f, 0x55, 0x9d, 0xf5, 0xd8, 0x52, 0xb7, 0x23, 0x4f, 0x6c, 0xde,
	0x00, 0x1b, 0xd6, 0x1b, 0x60, 0x17, 0x80, 0x6a, 0x6a, 0xf9, 0x0c, 0x24, 0x5f, 0x28, 0x2d, 0x0d,
	0xfb, 0x8d, 0x07, 0x8f, 0xd0, 0x4d, 0x38, 0x6e, 0x26, 0xa6, 0xca, 0x17, 0xc7, 0x59, 0x21, 0x5d,
	0xd3, 0xc8, 0x5b, 0x96, 0xee, 0xbb, 0xd0, 0x94, 0xb3, 0x29, 0x8b, 0x2d, 0xa4, 0x0b, 0x9a, 0x87,
	0xab, 0x7e, 0x18, 0x18, 0x71, 0xa4, 0x88, 0xd5, 0xcb, 0x99, 0x2c, 0xb3, 0x1d, 0x1d, 0xfb, 0x29,
	0xa6, 0xcc, 0x79, 0xa0, 0xb7, 0x46, 0x19, 0xc2, 0x1a, 0x17, 0x97, 0x76, 0xbc, 0x52, 0xe2, 0xcd,
	0xe6, 0x67, 0x3f, 0xf3, 0xa0, 0x33, 0xc8, 0x26, 0xa4, 0x20, 0x22, 0x56, 0x8f, 0x09, 0xd5, 0x2b,
	0xaf, 0x75, 0xb1, 0xf1, 0xaf, 0xbb, 0xd8, 0xd4, 0x9c, 0x4b, 0x80, 0x15, 0x3e, 0xeb, 0x6e, 0xf8,
	0x7c, 0x00, 0xeb, 0x27, 0x67, 0x79, 0x92, 0x9e, 0xf7, 0x4f, 0xf5, 0xeb, 0xb3, 0x96, 0xd9, 0x01,
	0x6c, 0x48, 0xc7, 0x13, 0xc5, 0x04, 0xb9, 0x7d, 0x5c, 0x8c, 0x6e, 0xf1, 0xa0, 0xf2, 0x5b, 0x0f,
	0x82, 0xea, 0x15, 0x53, 0x7a, 0x7e, 0x31, 0x0a, 0x9e, 0x40, 0x6b, 0x90, 0x4d, 0x56, 0x7a, 0x26,
	0xaa, 0x06, 0x58, 0x30, 0xfc, 0xe5, 0x60, 0x20, 0x0b, 0x5e, 0x24, 0x69, 0xfc, 0x2c, 0x1d, 0x0a,
	0x7a, 0x63, 0x44, 0x03, 0xad, 0x73, 0x47, 0xc7, 0x7e, 0x8d, 0xc1, 0xb2, 0x72, 0xde, 0x7e, 0x92,
	0x8e, 0x34, 0x03, 0x7a, 0xd0, 0x7e, 0x91, 0x67, 0x63, 0xb7, 0x2a, 0xb0, 0x55, 0xf2, 0x69, 0x36,
	0x1d, 0xa9, 0x94, 0xdd, 0xe2, 0x4a, 0x42, 0x1f, 0xd9, 0x8b, 0x0a, 0xe1, 0x9c, 0x8b, 0xa5, 0x31,
	0xdc, 0xaa, 0x2f, 0x1b, 0x48, 0x2f, 0x5d, 0x90, 0x59, 0x05, 0xb2, 0x82, 0xe0, 0x39, 0x10, 0xee,
	0x82, 0x3f, 0x28, 0x14, 0x11, 0xfd, 0x41, 0xb1, 0x7a, 0xec, 0xfe, 0x3e, 0xdc, 0xe3, 0xe2, 0x72,
	0xd9, 0xda, 0x58, 0x4f, 0xef, 0x2f, 0x3b, 0xfd, 0xaf, 0x3c, 0xb8, 0xaf, 0x49, 0xb6, 0xec, 0x22,
	0x6e, 0xb1, 0xed, 0xaf, 0x5a, 0x6c, 0xaf, 0x6a, 0x82, 0xbd, 0x8d, 0xbf, 0xbe, 0xeb, 0x7a, 0x7f,
	0x7f, 0xd7, 0xf5, 0xfe, 0xf1, 0xae, 0xeb, 0xfd, 0xf2, 0x9f, 0xdd, 0xcf, 0xfd, 0x27, 0x00, 0x00,
	0xff, 0xff, 0x7e, 0x0b, 0xc5, 0xf1, 0x90, 0x1a, 0x00, 0x00,
}
