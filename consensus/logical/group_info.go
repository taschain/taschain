//   Copyright (C) 2018 TASChain
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

package logical

import (
	"fmt"
	"math/big"
	"sync"

	"github.com/taschain/taschain/common"
	"github.com/taschain/taschain/consensus/groupsig"
	"github.com/taschain/taschain/consensus/model"
	"github.com/taschain/taschain/core"
	"github.com/taschain/taschain/middleware/types"
)

// StaticGroupInfo is static group structure (joined to GlobalGroups after
// the group is created and add-on-chain successfully)
type StaticGroupInfo struct {
	GroupID     groupsig.ID                   // Group ID (can be generated by the group public key)
	GroupPK     groupsig.Pubkey               // Group public key
	MemIndex    map[string]int                // Find member information by ID (member ID -> index in members)
	GInfo       *model.ConsensusGroupInitInfo // Fixed group info after consensus
	ParentID    groupsig.ID                   // Parent Group ID
	PrevGroupID groupsig.ID                   // Previous group id
}

func newSGIFromStaticGroupSummary(gid groupsig.ID, gpk groupsig.Pubkey, group *InitedGroup) *StaticGroupInfo {
	gInfo := group.gInfo
	sgi := &StaticGroupInfo{
		GroupID:     gid,
		GroupPK:     gpk,
		GInfo:       gInfo,
		ParentID:    gInfo.GI.ParentID(),
		PrevGroupID: gInfo.GI.PreGroupID(),
	}
	sgi.buildMemberIndex()
	return sgi
}

// newSGIFromCoreGroup convert the group info from chain to the StaticGroupInfo
func newSGIFromCoreGroup(coreGroup *types.Group) *StaticGroupInfo {
	gh := coreGroup.Header
	gis := model.ConsensusGroupInitSummary{
		Signature: *groupsig.DeserializeSign(coreGroup.Signature),
		GHeader:   gh,
	}
	mems := make([]groupsig.ID, len(coreGroup.Members))
	for i, mem := range coreGroup.Members {
		mems[i] = groupsig.DeserializeID(mem)
	}
	gInfo := &model.ConsensusGroupInitInfo{
		GI:   gis,
		Mems: mems,
	}
	sgi := &StaticGroupInfo{
		GroupID:     groupsig.DeserializeID(coreGroup.ID),
		GroupPK:     groupsig.DeserializePubkeyBytes(coreGroup.PubKey),
		ParentID:    groupsig.DeserializeID(gh.Parent),
		PrevGroupID: groupsig.DeserializeID(gh.PreGroup),
		GInfo:       gInfo,
	}

	sgi.buildMemberIndex()
	return sgi
}

func (sgi *StaticGroupInfo) buildMemberIndex() {
	if sgi.MemIndex == nil {
		sgi.MemIndex = make(map[string]int)
	}
	for index, mem := range sgi.GInfo.Mems {
		sgi.MemIndex[mem.GetHexString()] = index
	}
}

// GetMembers returns the member ids of the group
func (sgi *StaticGroupInfo) GetMembers() []groupsig.ID {
	return sgi.GInfo.Mems
}

// GetMinerPos get a miner's position in the group
func (sgi StaticGroupInfo) GetMinerPos(id groupsig.ID) int {
	pos := -1
	if v, ok := sgi.MemIndex[id.GetHexString()]; ok {
		pos = v
		// Double verification
		if !sgi.GInfo.Mems[pos].IsEqual(id) {
			panic("double check fail!id=" + id.GetHexString())
		}
	}
	return pos
}

// GetPubKey returns the public key of the group
func (sgi StaticGroupInfo) GetPubKey() groupsig.Pubkey {
	return sgi.GroupPK
}

// GetMemberCount returns the member count
func (sgi *StaticGroupInfo) GetMemberCount() int {
	return sgi.GInfo.MemberSize()
}

// GroupConsensusInited the group completes initialization and must be
// valid when a group has not been initialized
//
// pk: group public key after initialization
// id: group ID generated after initialization
func (sgi *StaticGroupInfo) GroupConsensusInited(pk groupsig.Pubkey, id groupsig.ID) bool {
	if sgi.GroupID.IsValid() || sgi.GroupPK.IsValid() {
		return false
	}
	if !pk.IsValid() || !id.IsValid() {
		return false
	}
	sgi.GroupID = id
	sgi.GroupPK = pk
	return true
}

func (sgi *StaticGroupInfo) getGroupHeader() *types.GroupHeader {
	return sgi.GInfo.GI.GHeader
}

// MemExist check if the specified miner is belong to the group
func (sgi StaticGroupInfo) MemExist(uid groupsig.ID) bool {
	_, ok := sgi.MemIndex[uid.GetHexString()]
	return ok
}

// GetMemberID gets the member id at the specified position
func (sgi *StaticGroupInfo) GetMemberID(i int) groupsig.ID {
	var m groupsig.ID
	if i >= 0 && i < len(sgi.MemIndex) {
		m = sgi.GInfo.Mems[i]
	}
	return m
}

// CastQualified check if the group is cast qualified at the specified height
func (sgi *StaticGroupInfo) CastQualified(height uint64) bool {
	gh := sgi.getGroupHeader()
	return IsGroupWorkQualifiedAt(gh, height)
}

// Dismissed means whether the group has been dismissed
func (sgi *StaticGroupInfo) Dismissed(height uint64) bool {
	return isGroupDissmisedAt(sgi.getGroupHeader(), height)
}

func (sgi *StaticGroupInfo) GetReadyTimeout(height uint64) bool {
	return sgi.getGroupHeader().ReadyHeight <= height
}

// GlobalGroup caches all work-group slices, and as the new group joins, the old group is dismissed,
// and the cache is constantly updated.
//
// Although we can get all the work-groups from the chain, the cache is to speed up the calculations.
type GlobalGroups struct {
	chain     *core.GroupChain
	groups    []*StaticGroupInfo // The work-group slices
	gIndex    map[string]int     // Group index supports quick retrieval of group information through group id(in hex string)
	generator *NewGroupGenerator // A new group generator
	lock      sync.RWMutex
}

func newGlobalGroups(chain *core.GroupChain) *GlobalGroups {
	return &GlobalGroups{
		groups:    make([]*StaticGroupInfo, 1),
		gIndex:    make(map[string]int),
		generator: CreateNewGroupGenerator(),
		chain:     chain,
	}
}

func (gg *GlobalGroups) GetGroupSize() int {
	gg.lock.RLock()
	defer gg.lock.RUnlock()
	return len(gg.groups)
}

func (gg *GlobalGroups) removeInitedGroup(gHash common.Hash) {
	gg.generator.removeInitedGroup(gHash)
}

func (gg *GlobalGroups) lastGroup() *StaticGroupInfo {
	return gg.groups[len(gg.groups)-1]
}

func (gg *GlobalGroups) findPos(g *StaticGroupInfo) (idx int, right bool) {
	cnt := len(gg.groups)
	if cnt == 1 {
		return 1, true
	}
	last := gg.lastGroup()

	// Just connected to the last one, most of the time this is the case
	if g.PrevGroupID.IsEqual(last.GroupID) {
		return cnt, true
	}

	// Belong to the group that follows, append to the end
	if g.getGroupHeader().WorkHeight > last.getGroupHeader().WorkHeight {
		return cnt, false
	}
	for i := 1; i < cnt; i++ {
		if gg.groups[i].getGroupHeader().WorkHeight > g.getGroupHeader().WorkHeight {
			return i, g.GroupID.IsEqual(gg.groups[i].PrevGroupID) && (i == 1 || g.PrevGroupID.IsEqual(gg.groups[i-1].GroupID))
		}
	}
	return -1, false
}

func (gg *GlobalGroups) append(g *StaticGroupInfo) bool {
	gg.groups = append(gg.groups, g)
	gg.gIndex[g.GroupID.GetHexString()] = len(gg.groups) - 1
	return true
}

// AddStaticGroup adda a legal effective group to the cache, which may be a work group currently or in the near future
//
// Consider the group synchronization process, the method may be called concurrently,
// resulting in the order of the groups being out of order
// It has to be processed carefully
func (gg *GlobalGroups) AddStaticGroup(g *StaticGroupInfo) bool {
	gg.lock.Lock()
	defer gg.lock.Unlock()

	result := ""
	blog := newBizLog("AddStaticGroup")
	defer func() {
		blog.log("id=%v, hash=%v, beginHeight=%v, result=%v\n", g.GroupID.ShortS(), g.getGroupHeader().Hash.ShortS(), g.getGroupHeader().WorkHeight, result)
	}()

	if _, ok := gg.gIndex[g.GroupID.GetHexString()]; !ok {
		if g.getGroupHeader().WorkHeight == 0 { // the genesis group
			gg.groups[0] = g
			gg.gIndex[g.GroupID.GetHexString()] = 0
			result = "success"
			return true
		}
		if idx, right := gg.findPos(g); idx >= 0 {
			cnt := len(gg.groups)
			if idx == cnt {
				gg.append(g)
				result = "append"
			} else {
				gg.groups = append(gg.groups, g)
				for i := cnt; i > idx; i-- {
					gg.groups[i] = gg.groups[i-1]
					gg.gIndex[gg.groups[i].GroupID.GetHexString()] = i
				}
				gg.groups[idx] = g
				gg.gIndex[g.GroupID.GetHexString()] = idx
				result = "insert"
			}
			if right {
				result += "and linked"
			} else {
				result += "but not linked"
			}
			return true
		}
		result = "can't find insert pos"
	} else {
		result = "already exist this group, ignored"
	}
	return false
}

// IsGroupMember check if a user is a member of a group
func (gg *GlobalGroups) IsGroupMember(gid groupsig.ID, uid groupsig.ID) bool {
	g, err := gg.GetGroupByID(gid)
	if err == nil {
		return g.MemExist(uid)
	}
	return false
}

func (gg *GlobalGroups) getGroupByIndex(i int) (g *StaticGroupInfo, err error) {
	if i >= 0 && i < len(gg.groups) {
		g = gg.groups[i]
	} else {
		err = fmt.Errorf("out of range")
	}
	return
}

func (gg *GlobalGroups) getGroupFromCache(id groupsig.ID) (g *StaticGroupInfo, err error) {
	gg.lock.RLock()
	defer gg.lock.RUnlock()

	index, ok := gg.gIndex[id.GetHexString()]
	if ok {
		g, err = gg.getGroupByIndex(index)
		if !g.GroupID.IsEqual(id) {
			panic("ggIndex error")
		}
	}
	return
}

// GetGroupByID returns the group info of the specified id.
func (gg *GlobalGroups) GetGroupByID(id groupsig.ID) (g *StaticGroupInfo, err error) {
	if g, err = gg.getGroupFromCache(id); err != nil {
		return
	}
	if g == nil {
		chainGroup := gg.chain.GetGroupByID(id.Serialize())
		if chainGroup != nil {
			g = newSGIFromCoreGroup(chainGroup)
		}
	}
	if g == nil && stdLogger != nil {
		stdLogger.Debugf("^^^^^^^^^^^^^^^^^^GetGroupByID nil, gid=%v\n", id.ShortS())
		for _, g := range gg.groups {
			stdLogger.Debugf("^^^^^^^^^^^^^^^^^^GetGroupByID cached groupid %v\n", g.GroupID.ShortS())
		}
		g = &StaticGroupInfo{}
	}
	return
}

func (gg *GlobalGroups) selectIndex(num int, hash common.Hash) int64 {
	value := hash.Big()
	index := value.Mod(value, big.NewInt(int64(num)))
	return index.Int64()
}

// SelectNextGroupFromCache determines the next verification group through the cached work-group slices according to the previous random number.
// The result is random and certain
func (gg *GlobalGroups) SelectNextGroupFromCache(h common.Hash, height uint64) (groupsig.ID, error) {
	qualifiedGS := gg.GetCastQualifiedGroups(height)

	var ga groupsig.ID

	gids := make([]string, 0)
	for _, g := range qualifiedGS {
		gids = append(gids, g.GroupID.ShortS())
	}

	if h.Big().BitLen() > 0 && len(qualifiedGS) > 0 {
		index := gg.selectIndex(len(qualifiedGS), h)
		ga = qualifiedGS[index].GroupID
		stdLogger.Debugf("height %v SelectNextGroupFromCache qualified groups %v, index %v\n", height, gids, index)
		return ga, nil
	}
	return ga, fmt.Errorf("selectNextGroupFromCache failed, hash %v, qualified group %v", h.ShortS(), gids)
}

func (gg *GlobalGroups) getCastQualifiedGroupFromChains(height uint64) []*types.Group {
	iter := gg.chain.NewIterator()
	groups := make([]*types.Group, 0)
	for g := iter.Current(); g != nil; g = iter.MovePre() {
		if IsGroupWorkQualifiedAt(g.Header, height) {
			groups = append(groups, g)
		} else if isGroupDissmisedAt(g.Header, height) {
			g = gg.chain.GetGroupByHeight(0)
			groups = append(groups, g)
			break
		}
	}
	n := len(groups)
	reverseGroups := make([]*types.Group, n)
	for i := 0; i < n; i++ {
		reverseGroups[n-i-1] = groups[i]
	}
	return reverseGroups
}

// SelectNextGroupFromChain determines the next verification group through the chained work-groups according to the previous random number.
// The result is random and certain, and mostly should be the same as method SelectNextGroupFromCache
//
// This method can be used to compensate when the result of the calculation through the cache(method SelectNextGroupFromCache)
// does not match the expectation
func (gg *GlobalGroups) SelectNextGroupFromChain(h common.Hash, height uint64) (groupsig.ID, error) {
	quaulifiedGS := gg.getCastQualifiedGroupFromChains(height)
	idshort := make([]string, len(quaulifiedGS))
	for idx, g := range quaulifiedGS {
		idshort[idx] = groupsig.DeserializeID(g.ID).ShortS()
	}

	var ga groupsig.ID
	if h.Big().BitLen() > 0 && len(quaulifiedGS) > 0 {
		index := gg.selectIndex(len(quaulifiedGS), h)
		ga = groupsig.DeserializeID(quaulifiedGS[index].ID)
		stdLogger.Debugf("height %v SelectNextGroupFromChain qualified groups %v, index %v\n", height, idshort, index)
		return ga, nil
	}
	return ga, fmt.Errorf("SelectNextGroupFromChain failed, arg error")
}

// GetCastQualifiedGroups gets all work-groups at the specified height
func (gg *GlobalGroups) GetCastQualifiedGroups(height uint64) []*StaticGroupInfo {
	gg.lock.RLock()
	defer gg.lock.RUnlock()

	gs := make([]*StaticGroupInfo, 0)
	for _, g := range gg.groups {
		if g == nil {
			continue
		}
		if g.CastQualified(height) {
			gs = append(gs, g)
		}
	}
	return gs
}

// GetAvailableGroups gets all valid groups at a given height, including those can work currently or in the near future
func (gg *GlobalGroups) GetAvailableGroups(height uint64) []*StaticGroupInfo {
	gg.lock.RLock()
	defer gg.lock.RUnlock()

	gs := make([]*StaticGroupInfo, 0)
	for _, g := range gg.groups {
		if g == nil {
			continue
		}
		if !g.Dismissed(height) {
			gs = append(gs, g)
		}
	}
	return gs
}

func (gg *GlobalGroups) GetInitedGroup(gHash common.Hash) *InitedGroup {
	return gg.generator.getInitedGroup(gHash)
}

func (gg *GlobalGroups) DismissGroups(height uint64) []*StaticGroupInfo {
	gg.lock.RLock()
	defer gg.lock.RUnlock()

	ids := make([]*StaticGroupInfo, 0)
	for _, g := range gg.groups {
		if g == nil {
			continue
		}
		if g.Dismissed(height) {
			ids = append(ids, g)
		}
	}
	return ids
}

func (gg *GlobalGroups) removeGroups(gids []groupsig.ID) {
	if len(gids) == 0 {
		return
	}
	removeIDMap := make(map[string]bool)
	for _, gid := range gids {
		removeIDMap[gid.GetHexString()] = true
	}
	newGS := make([]*StaticGroupInfo, 0)
	for _, g := range gg.groups {
		if g == nil {
			continue
		}
		if _, ok := removeIDMap[g.GroupID.GetHexString()]; !ok {
			newGS = append(newGS, g)
		}
	}
	indexMap := make(map[string]int)
	for idx, g := range newGS {
		indexMap[g.GroupID.GetHexString()] = idx
	}

	gg.lock.Lock()
	defer gg.lock.Unlock()

	gg.groups = newGS
	gg.gIndex = indexMap
}

func (gg *GlobalGroups) getGenesisGroup() *StaticGroupInfo {
	if gg.GetGroupSize() == 0 {
		return nil
	}
	g := gg.groups[0]
	if g.GInfo.GI.GHeader.WorkHeight != 0 {
		panic("genesis group error")
	}
	return g
}
